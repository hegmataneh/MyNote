if #include "DefAndSyntaxHighlightingAssistant.h" added at the end of include file then syntax highlighter recognize it

and fill it with 
consider these header files and all its sub header files
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdarg.h>
#include <sys/time.h>
#include <sys/select.h>
#include <sys/types.h>          /* See NOTES */
#include <time.h>
and please get me just most used definition of content that exist in headers without any comment  in one text result no bullet or partition at all

in deepseek

--

add __INTELISENSE_BUILD__=$(IntelliSenseBuild) into project properties -> c/c++ -> preprocessor -> preprocessor definition to distigush intellisence time in project then
write this in .c code

#if defined(INTELISENSE_BUILD) && INTELISENSE_BUILD + 0

typedef unsigned long size_t;
typedef void * va_list;

#endif

that do intellisence compiler know type


14040404
--------------------

add
d:\workplace\config\.gitattributes
d:\workplace\config\.gitignore
to .git folder to ignore non usable file to staged and push into git


مجددا رسیدیم به زبان زیبای سی که الکی بامبول در میاره و دوباره ریبیلد گاهی خطا رو درست میکنه و همه چیز رو ببندیم و مجدد باز کنیم

نکنه  از این مشکلات نوستن در حافظه بقیه جاها رو داشته باشیم و مموری کنترل اصلا نداشته باشیم



sudo agt-get install man
sudo agt-get install man-db

sudo unminimize

14040402

----------------


14040401

sudo mount -t vboxsf workplace /home/mohsen/workplace 

----------------

// send udp packet throw port 1234 with netcat
echo "hello" | nc -u 127.0.0.1 1234

sudo apt-get install netcat-traditional


read() is a general file I/O function, while recvfrom() is specifically for socket communication.


recvfrom() provides the source address of the incoming data, which is crucial for connectionless protocols where the sender's address is not implicitly known through a prior connection. read() does not provide this information.


A C language TCP server can accept connections on multiple ports by creating and managing multiple listening sockets, each bound to a different port. A single TCP socket cannot listen on multiple ports simultaneously


epoll is a Linux-specific API that offers better scalability for a large number of file descriptors, especially in high-performance network servers.


--------

https://faradars.org/courses/fvgit9609-git-github-gitlab?registered=1

https://git-scm.com/downloads/win

git init

d:\to hear\Network_Pakravan\

git status

rm -rf .git   # use 'rmdir /s /q .git' in Windows CMD

# Create a clean folder and reinitialize
mkdir MyProject
cd MyProject
git init


git config --global user.name 'mohsen'
git config --global user.email "mohsensherkatmasoum@gmail.com"


ou can check what’s currently configured with:
git config --global --list


git ls-files // get all tracked files

git log --name-only // To see which files were modified in each commit

git add "page*" // just check in files started with page...


tracking new file
git add -A // add all files گیت فایل را در نظر می گیرد
همه رو ببر درstage
یعنی آماده چک این شدن می شوند

HEAD اون چیزی است که الان رویش کار می کنیم

git commit -m 'comment'
git commit -a -m 'commit changes by man' // commit changes with comment

git diff // اگر یک فایل تغییر کرده داشته باشیم و کامیت نکرده باشیم این باعث می شود که احتلاف مشاهده شود

git diff HEAD // مقایسه با آخرین ورژن


وقتی یک فایل تغییر می کند آنرا به استیج منتقل می کنیم بعد وقتی کامیت می کنیم به ریپوزتوری اضافه می شود

یک مرحله استیج اضافه کرده که یعنی فقط چیز هایی که قرار است کامیت شود انتخاب شود یک اضافه کردن یک مرحله ی جدید برای جلوگیری از کامیت و خراب شدن موارد خراب اضافه کرده

git diff --staged // موارد داخل استیج رو مقایسه گیری می کند

عدد منفی در گیت یعنی زمان گذشته فایل و مثبت یعنی جدیده

git restore "file" // ignore changes to file and replace with commited version from source control


git reset "file" // از استیج خارج می کند

git checkout -- "file" // آخرین ورژن فایل را دریافت می کند

master یا main اسم شاخه اصلی است

git branch // شاخه های پروژه نمایش داده می شود

git branch sth. // شاخه جدیدی اضافه می کند با نام مشخص که می شود روی اون شاخه کاری رو ادامه داد و بعدا با مین یا مستر مرج کرد


git checkout sth. // برنچ با نام خاصی رو می کشد بیرون یا اماده تغییر می کند
و در واقع این شاخه اماده تغییر می شود

git merge sth. // تغییرات برنچ دیگر را در مستر یا مین اضافه می کند

--- install nano for windows

download it from https://github.com/okibcn/nano-for-windows/releases

copy it to program file

add environment variable -> system variable -> path -> dir of nano like c:\Program Files\nano

close and open again console and write nano --version

------------

git rm file // remove from git branch and file system


یک نکته مهم اینه که هر کامیت یک کاری بکند

یک چیز جالب وقتی یک فایل را در برنچی پاک می کنیم و تا وقتی که در ان برنچ کامیت نکردیم در بقیه برنچ ها هم اون فایل دیگر در فایل سیستم مشاهده نمی شود ولی به محض کامیت در یک برنچ دیگر برنچ ها می فهمند که اون تغییر در دیگر برنچ است فلذا اون فایل دلیت شده در اون یکی برنچ قابل مشاهده است

بعد از اینکه برنچ فرعی با اصلی مرج شد می شود پاکش کرد با دستور

git branch -d sth. // delete some branch



git clone remoteaddrs

نسخه اصلی
origin
است 


git push origin master // send taghirat to branch origin github repository from main branch in local cloned repository

git pull origin main // from github to local repository


git remote add origin addrss // یک ادرس ریموت برای اوریجین یعنی نسخه تخت گیت هاب چیزی که ما داریم اضافه می کند
حالا اینجا معنی میده که بگیم
git push -u  origin master
که یعنی داره میگه حالا که برای مستر اوریجین تعیین کریم بیا مستر رو بفرست روی گیت هاب. نگکته باحال اینست که می شود برای یک مستر یا مین چند ریموت تعیین کرد که یعنی چند جا چک این کن که امنیت حفظ شود



CONFLICT (content): Merge conflict in simulator/s4u-activity-testany.cpp
Automatic merge failed; fix conflicts and then commit the result.

git add -A // staged all files

------- 009

tag // بیشتر برای ورژن زدن استفاده می شود

git tag // list all tag

git tag -a v2.0 -m "text tax" // یعنی تگ بزن روی نسخه انتخابی فعلی و اسمش را بزار ورژن 2 و یک کامنت بزار براش

خاصیتش اینست که میتونیم برنامه را نسخه دار کنیم یعنی بگیم نسخه فلان را برای ما الان آماده کن و ببینیمش یا برنچش کن برای ما که اونرو ادامه بدیم


تگ در حالت عادی روی گیت هاب پوش نمی شود ولی می توان گفت بزرو پوشش کن

git push origin v1.8  // نسخه مشخصی رو بفرست سمت ریموت
git push origin --tags // همه تگ ها بفرست سمت ریموت


اینجوری می شود یک ورژن مشخص را برای ادیت به عنوان هد قرار داد
git checkout v2.0
البته درستش اینه که اگر می خواهیم روی یک ورژن قدیمی کار کنیم یک برنچ بسازیم و اونرو ادامه بدیم
git checkout -b branch_name


----- 010

امضای دیجیتال همه چیز از جمله ورژن و کامیت و غیره با کلید
gpg
که یک برنامه نصبی است

-------- 011

git help blame // توضیح واضحی از ابزار های گیت

دنبال ابزاری هستیم که با روش نیوتون بابک حافظی پی ببریم کدام ورژن ما خراب کرده در اجرا این ابزار 

bisect
نام دارد

git bisect start
git bisect bad

...

git bisect good

با زدن دستور استارت و اینکه الان اوضاع خرابه و با پیشنهاد گیت که ورژن را ÷یپشنهاد میده میشه فهمید کدام ورژن خراب شده

------ 012


pull request

یعنی ریپوزیتوری اصلی را یک فورک رویش میزنه و می اندازیم در یوزر خودمان بعد تغییراتی که روی نسخه خودمان هست را اجرا می کنیم و بعد می توانیم به سازنده اصلی ریپو بگیم بیا این فایل ما که تغییر کرده را بگیر بنداز روی نسخه اولیه

------

git add *.c
git add *.cpp
git add *.h

git remote add origin https://github.com/hegmataneh/work.git

git push origin main

خلاصه چند تا فولدر مجزا رو در یک ریپوزیتوری نمیشه اد کرد
هر کی ریپوز خودش

------

do things:

https://ubuntu.com/download/server/thank-you?version=24.04.2&architecture=amd64&lts=true
install ubuntu

sudo apt upgrade
sudo apt update

sudo apt install mc

https://phoenixnap.com/kb/install-gcc-ubuntu

network ping

sudo apt install net-tools

----------------------------------------------------

install ssh
https://hostman.com/tutorials/how-to-install-and-configure-ssh-on-ubuntu-22-04/

-------------------------------------------------------------------------

sudo nano /etc/netplan/01-netcfg.yaml


intellisence 

Install Necessary Tools on Linux
On your Linux system, install essential development tools:

bash
Copy
Edit
sudo apt update
sudo apt install build-essential gcc g++ gdb zip rsync
sudo apt install -y make cmake



3. Synchronize Remote Headers
To enable IntelliSense to recognize Linux headers:

In Visual Studio, go to Tools > Options > Cross Platform > Connection Manager > Remote Headers IntelliSense Manager.

Select your Linux connection from the list.

Click Update to download the headers from the remote system.
devblogs.microsoft.com


Include Remote Headers in Project Settings
Ensure the remote headers are included in your project's include paths:

In the project properties, go to Configuration Properties > C/C++ > General > Additional Include Directories.

Add the following:

javascript
Copy
Edit
$(RemoteHeadersDir)

------------


tets nmap

diagnose of of domain nmap -O <Domain Name>

inet-utils-traceroute



sudo apt install hping3


iptables -t nat -L

sudo sysctl -a | grep broad

----------
history of shell command
history | awk '{$1=""; print $0}' | sed 's/^ *//' | sort | uniq



sudo apt install openssh-server



hping3 -1 -c 1 192.168.100.200  -- ping icmp one time to ip


sudo adduser mohsen

ssh mohsen@192.168.100.201


sudo apt-get install ninja-build

---------


configuration properties
	c/c++
		advance
Compile as C Code (-x c)

-------

Additional Include Directories
$(RemoteRootDir)/$(ProjectName)/dep;
$(RemoteRootDir)/$(ProjectName)/header;
%(ClCompile.AdditionalIncludeDirectories);
$(RemoteHeadersDir);

--------

configuration properties
	copy sources
		additional sources to copy 
d:\My project\General projects\general\dep\general.dep:=$(RemoteRootDir)/$(ProjectName)/dep/general.dep;d:\My project\General projects\general\dep\general.use:=$(RemoteRootDir)/$(ProjectName)/dep/general.use;d:\My project\General projects\general\dep\general.inc:=$(RemoteRootDir)/$(ProjectName)/dep/general.inc


-----------

خروجی ها در linux console نمایان می شود

-----------


ignore warning : ‘’ defined but not used [-Wunused-function]

with attribute -Wno-unused-function in

project properties
	c/c++
		command line
		
--------------

📜 Major versions of C (chronological order):
Version	Year	Key Features Introduced
C89/C90	1989/1990	First standardized C version (ANSI/ISO)
C99	1999	New types (long long, _Bool), inline, // comments, variable declarations anywhere, designated initializers, etc.
C11	2011	_Atomic, multi-threading support, static_assert, etc.
C17	2017	Bug fixes to C11, no new features
C23	2023	Modern updates, including memory safety improvements


---------

recongize c version

in ubuntu
echo | gcc -x c -E -dM - | grep __STDC_VERSION__


in code
 #if __STDC_VERSION__ >= 202311L
        printf("C23\n");
    #elif __STDC_VERSION__ >= 201710L
        printf("C17\n");
    #elif __STDC_VERSION__ >= 201112L
        printf("C11\n");
    #elif __STDC_VERSION__ >= 199901L
        printf("C99\n");
    #else
        printf("C89/C90\n");
    #endif
	
	
---------------

هر وقت تغییری در فایل های 
dep
می دادم امکان داشت این تغییر در کامپایل اعمال نشود فلذا باید
clean
می کردم و مجدد تست می کردم


---

حواسمان هست که کامپایل ریموت سمت اوبونتو انجام می شود پس از هدر و دپ و یوز های ارسال شده به اون ماشین استفاده می کند
حالا نکته ای که هست هرچقدر کلین یا هرچی با ویپزوال استادیو بزنیم بعضی فایل ها کلین نمی شود پس فقط ریبیلد هست که فایل ها را مجدد به ماشین ارسال می کند
اگر راهی باشد که هر بیلد فایل بفرستد که خوب است ولی فعلا که پیدا نشد
و کام÷ایل تک فایل هم بدترین کار است

-------

to find header in my linux
find /usr/include -name string.h

to check function
grep strdup /usr/include/string.h


View default include search paths for GCC
echo | gcc -E -Wp,-v -

man command in Linux is used to display the user manual of any command that we can run on the terminal


مشکلی که سر تابع
strdup
مشاهده شد اینست که کامپایلر بهش گیر میداد فلذا راه حلی که انجام شد اضافه کردن 
-D_POSIX_C_SOURCE=200809L
به آرگومان های کامپایلر هست که برای اینکار از این مقدار را در
project properties - c/cpp - command line - additional options - -D_POSIX_C_SOURCE=200809L 
اضافه می گردد


But also note: strdup is not part of ANSI C (C89), but it is available in POSIX. Some environments require defining a feature macro, or using a compiler flag like -D_POSIX_C_SOURCE=200809L.

----

از یک ورژن کامپایلر gcc به بعد می توان به آن آرگومان پاس داد پس حالا می خواهیم warning  های بیخوری را در سطح بلاک یا کد حذف کنیم که بیخودی خروجی کام÷ایلر شلوغ نشود میاییم از این دستورات کمک  می گیریم

#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic push
#pragma GCC diagnostic pop


https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html

---------

libyaml از ادرس 
https://pyyaml.org/wiki/LibYAML
دانلود شد


---

mkdir -p make dir with all root path

ls -a ~ list hiddent file and folder in address for home user directory

-------

برای لینکر بین general و پروژه ی خودم به مشکل خوردم که با اضافه کردن references در general به پروژه ی خودم مشکل لینک حل شد

---------

CMake is a cross-platform build system generator

------

اگر بخواهم از تابع fork برای هندل حجم کار استفاده کنم باید حواسم به محدودیت های تعداد برای هر بوزر و کل سیستم باشد


وقتی یک cross platform جدید می سازیم پروژه های قدیمی هم کانفیگش خراب می شود و روی ip جدیده قرار می گیرد و باید دستی درست شود




tcpdump udp dst port 1234


--------


