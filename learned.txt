
ssh to root user to wrap around sudo need for gdb in visual studio 2022

Check dynamic linkage
{
	ldd $(which tcpdump) | grep pcap
}

14040513
------------

NIC
{
	NIC memory can allocate
	{
		sudo sysctl -a | grep mem
		
		sudo sysctl -p
	}

	NIC static // network card stat
	{
		sudo watch -n 1 ethtool -S enp0s3
		
		sudo watch -n 1 ip -i enp0s3 -s link
		
		nc -u -l // show packet received

		//  iterativly do one thing with interval
		{
			watch -n 1 netstat -su // هر ثانیه مثلا یک دستور را اجرا می کند و نتیجه را می نویسد
		}
		
		tools use to monitor network throughput
		{
			sudo pktstat -i enp0s3 // to more check and use

			watch -n 1 netstat -su // to watch sumup report

			pcap file (packet capture file).

			wireshark: GUI packet analyzer

			netstat / ss: shows open ports and connections

			iptraf-ng, bmon, pktstat: per-port and per-protocol stats

			Traffic shaping, buffer overrun, and congestion control
		}

		netstat -su // Overrun / dropped packets

		show me sample about tc command in linux

		to monitore tcp and udp socket

		Linux tc (Traffic Control) & ss (Socket Statistics)
	}
}


posix_memalign // ?

compiler trick
{
	sudo apt-get install ninja-build	

	---------

	configuration properties
		c/c++
			advance
	Compile as C Code (-x c)

	-------

	Additional Include Directories
	$(RemoteRootDir)/$(ProjectName)/dep;
	$(RemoteRootDir)/$(ProjectName)/header;
	%(ClCompile.AdditionalIncludeDirectories);
	$(RemoteHeadersDir);

	--------

	configuration properties
		copy sources
			additional sources to copy 
	d:\My project\General projects\general\dep\general.dep:=$(RemoteRootDir)/$(ProjectName)/dep/general.dep;d:\My project\General projects\general\dep\general.use:=$(RemoteRootDir)/$(ProjectName)/dep/general.use;d:\My project\General projects\general\dep\general.inc:=$(RemoteRootDir)/$(ProjectName)/dep/general.inc		
	
	
	برای لینکر بین general و پروژه ی خودم به مشکل خوردم که با اضافه کردن references در general به پروژه ی خودم مشکل لینک حل شد


	از یک ورژن کامپایلر gcc به بعد می توان به آن آرگومان پاس داد پس حالا می خواهیم warning  های بیخوری را در سطح بلاک یا کد حذف کنیم که بیخودی خروجی کام÷ایلر شلوغ نشود میاییم از این دستورات کمک  می گیریم

	#pragma GCC diagnostic ignored "-Wsign-conversion"
	#pragma GCC diagnostic push
	#pragma GCC diagnostic pop

	https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html	
	
	مشکلی که سر تابع
	strdup
	مشاهده شد اینست که کامپایلر بهش گیر میداد فلذا راه حلی که انجام شد اضافه کردن 
	-D_POSIX_C_SOURCE=200809L
	به آرگومان های کامپایلر هست که برای اینکار از این مقدار را در
	project properties - c/cpp - command line - additional options - -D_POSIX_C_SOURCE=200809L 
	اضافه می گردد

	But also note: strdup is not part of ANSI C (C89), but it is available in POSIX. Some environments require defining a feature macro, or using a compiler flag like -D_POSIX_C_SOURCE=200809L.
	
	-----------

	ignore warning : ‘’ defined but not used [-Wunused-function]

	with attribute -Wno-unused-function in

	project properties
		c/c++
			command line
			
	-------

	CMake is a cross-platform build system generator
	
	-----
	
	to set app properties

	extention to delete on clean -> *.dep;*.inc;*.use;*.d;*.tlog;$(ExtensionsToDeleteOnClean)
	library dependency -> ncurses

	c/c++ additional options -> -D__COMPILE 

	in dep file -> #if !defined(__COMPILE) && defined(__PROJECT_NAME__) && __PROJECT_NAME__ == ##project name##
	
	--------
	
 با یک تغییراتی در کد بعضی وقتا یادش میفته وارنینگ ها رو رو کنه
 
}

نکات فنی مشاهدات
{
	- وقتی روی پورت udp سلکت بدون تایم اوت می زنیم وقتی پکتی دریافت می کند سریع خبر می دهد ولی با تایم اوت دچار مشکل می شود و دیگر دیتا نمی خواندن
	- اشکالی که مشاهده شد اینست که گویا ارتباط شبکه ای ماشین مجازی اشکالی دارد و باعث می شود که کندی مقطعی در دوره هایی ایجاد گردد و جریان دایم داده ایجاد نشود
	- مجددا رسیدیم به زبان زیبای سی که الکی بامبول در میاره و دوباره ریبیلد گاهی خطا رو درست میکنه و همه چیز رو ببندیم و مجدد باز کنیم
	- نکنه از این مشکلات نوستن در حافظه بقیه جاها رو داشته باشیم و مموری کنترل اصلا نداشته باشیم
	
}

نکات و سرفصل هایی که مشاهده شده
{
	crossbar switch - جدول متقاطع پردازنده و مموری

	systolic array - آرایه پردازشی

	FPGA - Field Programmable Gate Array	
	
}

14040512
----------------

network trick
{
	ip link // interfaces

	network namespace
	sudo ip netns add testns // make namespace like new env for testing network
	sudo ip netns exec testns bash // exec bash app in that namespace . so every network command i exec is exec inside namespace

	sudo ip netns delete testns // delete namespace
	ip netns list // list namespaces

	ip netns identify $$ // test inside namespace
}

proxychains // how to use ipchains to pass packet from virtual machine traffic to psiphon run on host 
{
	install proxychains
	
	sudo nano /etc/proxychains.conf
	
	at [ProxyList] -> 
	{
		comment -> socks4         127.0.0.1 9050
		insert -> socks5 192.168.100.6 9001
	}
	
	open windows firewall and open port 9001 for example
	
	take care of netlimiter
	
	at windows
	{
		by admin cmd insert -> netsh interface portproxy add v4tov4 listenport=9001 listenaddress=0.0.0.0 connectport=1080 connectaddress=127.0.0.1
		// 1080 is port of psiphon3 in local proy port
		{
			netsh interface portproxy show all // to ckeck rule
			netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0 // to remove rule
		}
	}
	
	and exec every cmd need proxy with -> sudo proxychains apt update // for exmaple
	
	sudo proxychains wget https://packages.ntop.org/apt/ntop.key
	sudo proxychains apt install pfring
	sudo proxychains apt-get update
	sudo proxychains apt-get install -y build-essential git linux-headers-$(uname -r) libnuma-dev libnl-genl-3-dev net-tools ethtool
	sudo proxychains curl -s -L facebook.com
	sudo proxychains apt-get install build-essential bison flex linux-headers-$(uname -r) libnuma-dev libnl-genl-3-dev
	sudo proxychains apt install libpcap-dev
}


virtual box ubuntu internet broken
{
	sudo nano /etc/netplan/01-netcfg.yaml

	network:
	  version: 2
	  ethernets:
		enp0s3:
		  dhcp4: no
		  addresses: [192.168.100.60/24]
		  gateway4: 192.168.100.254  <<<<<<<<-------------
		  nameservers:
			addresses: [8.8.8.8]
}

To reach line-rate speeds (e.g., 10Gbps+) with high-performance packet generators
{
	pfring
	{
		to fix linkage error for "/usr/bin/ld : error : /usr/local/lib/libpfring.so: undefined reference to pcap_compile_nopcap'"
		->
		-sudo apt install libpcap-dev
		-rebuild PF_RING
		{
			cd /path/to/pf_ring/source
			make clean
			make
			sudo make install
			sudo ldconfig # refresh cache
		}
		
		add "/usr/local/lib" and "/usr/local/include" to project properties
	}
	
	
	high-performance network stacks
	{
		DPDK (Data Plane Development Kit)
		{
			Description: A framework for fast packet processing in user space, directly interfacing with the NIC using poll-mode drivers.
			Performance: Line-rate at 10/40/100Gbps with low CPU usage.
			Packet Generator: Comes with testpmd and pktgen-dpdk (dedicated packet generator).
			Bypass Kernel: Yes (uses uio or vfio drivers).
			Use Case: Benchmarking NICs, network appliances, middleboxes.
			Website: https://www.dpdk.org/
		}
		PF_RING ZC (Zero Copy)
		{
			Description: High-speed packet I/O framework by ntop, allowing zero-copy operations with compatible NICs.
			Packet Generator: pf_ring_zc_send, or use their test apps.
			Bypass Kernel: Yes.
			Ubuntu Use: Works well with Ubuntu; needs compatible NIC and PF_RING installed.
			Website: https://www.ntop.org/products/packet-capture/pf_ring/
		}
		XDP (eXpress Data Path) + AF_XDP
		{
			Description: Fast in-kernel packet processing with option to send/receive from user space using AF_XDP sockets.
			Bypass Kernel: Partial (XDP can bypass parts of the network stack).
			Use Case: Custom fast packet send/recv, integration with eBPF.
			Ubuntu Support: Good on recent Ubuntu kernels (>= 5.4).
			Documentation: https://www.kernel.org/doc/html/latest/networking/af_xdp.html
		}
		MoonGen
		{
			Description: A high-speed packet generator based on DPDK, using Lua scripts for configuration.
			Performance: Excellent; precise control of packet rate and timing.
			Scriptable: Yes, via Lua.
			Bypass Kernel: Yes (uses DPDK).
			GitHub: https://github.com/emmericp/MoonGen
		}
		
		libpcap
		DPDK (Data Plane Development Kit)
		{
			Website: https://www.dpdk.org
			Use case: Bypasses the Linux kernel network stack to provide user-space fast packet processing.
			Performance: Millions of packets per second per core.
			Tested on Ubuntu: Official support for Ubuntu (LTS versions like 20.04, 22.04).
			Driver: Works with vfio, uio_pci_generic, or igb_uio kernel modules.
			Pros:
				Low latency, high throughput.
				Huge ecosystem and NIC vendor support.
			Cons:
				Complex setup.
				Not POSIX socket API compatible (requires app rewrite or use of wrappers).
		}
		XDP (eXpress Data Path) + AF_XDP
		{
			Website: https://xdp-project.net
			Use case: High-speed packet processing inside the kernel or user-space with AF_XDP sockets.
			Performance: Comparable to DPDK in many cases.
			Tested on Ubuntu: Fully supported on Ubuntu 20.04+ with Linux kernel 5.4+.
			Pros:
				Runs inside kernel (XDP) or user space (AF_XDP).
				Easier than DPDK in many scenarios.
				Maintains compatibility with Linux networking.
			Cons:
				Less mature than DPDK in tooling and NIC driver support.
				Requires kernel ≥ 5.3+ for AF_XDP full support.
		}
		netmap
		{
			Website: https://github.com/luigirizzo/netmap
			Use case: Kernel-bypass packet I/O for fast traffic capture, generation, and forwarding.
			Performance: Comparable to DPDK for some tasks.
			Tested on Ubuntu: Works on Ubuntu but may require kernel patching or DKMS module.
			Pros:
				Simple API, close to BSD sockets.
				Good for packet capture and replay.
			Cons:
				Not as active as DPDK/XDP.
				Limited NIC driver support.
		}
		VPP (Vector Packet Processing)
		{
			Website: https://fd.io
			Use case: Framework from FD.io for programmable high-speed packet processing.
			Performance: Excellent throughput using vectorized packet processing.
			Tested on Ubuntu: Has Ubuntu packages and documentation (20.04, 22.04).
			Pros:
				High-level programming and CLI tools.
				Built-in support for NAT, IPsec, VXLAN, etc.
			Cons:
				Complex to configure.
				Requires new architecture thinking.
		}
		Snabb
		{
			Website: https://snabbco.org
			Use case: Lightweight LuaJIT-based network stack.
			Performance: High speed, designed for NFV use cases.
			Tested on Ubuntu: Requires some setup and is more niche.
			Pros:
				Minimalist, scriptable with LuaJIT.
			Cons:
				Not widely adopted.
				Smaller community and support.
		}
		PF_RING // much faster than libpcap
		{
			Website: https://www.ntop.org/products/packet-capture/pf_ring/
			Developed by: ntop
			Type: Kernel module + user-space API
			Use case: High-speed packet capture and analysis with or without kernel bypass.
			Ubuntu support: Actively tested on Ubuntu 18.04, 20.04, 22.04 (DEB packages available).

			✅ Features
				High-performance packet capture: Much faster than raw libpcap.
				Zero-copy mode: Via PF_RING ZC (requires compatible NICs).
				Compatible with libpcap: Tools like tcpdump, Wireshark, nprobe, and ntopng can benefit with minimal change.
				Multi-threaded: Works efficiently on multicore CPUs.
				Supports NIC drivers: Like Intel iXGBE, i40e with custom ZC drivers.
			
			Recommendation for Ubuntu (stable + performance):
			{
				Beginner: Try XDP + AF_XDP. It has less overhead to get started and integrates with normal Linux networking.
				Advanced: Use DPDK if you need full user-space packet processing and best throughput.
				Middle-ground: Try VPP if you're building complex network apps (like routers/firewalls).
			}
		}
		
		🔄 PF_RING vs Others:
			| Feature              | PF\_RING            | DPDK           | XDP + AF\_XDP     | Netmap   | VPP  |
			| -------------------- | ------------------- | -------------- | ----------------- | -------- | ---- |
			| Kernel bypass        | Partial (ZC mode)   | Yes            | Partial           | Yes      | Yes  |
			| POSIX socket API     | Yes (libpcap-like)  | No             | No                | Limited  | No   |
			| Complexity           | Low–Medium          | High           | Medium            | Medium   | High |
			| Packet capture speed | Very high (ZC mode) | Extremely high | Very high         | High     | High |
			| Ubuntu support       | Excellent           | Excellent      | Excellent         | Moderate | Good |
			| Suitable for IDS     | ✅ (e.g. Suricata)  | ❌ (complex)   | ⚠️ (raw handling) | ⚠️       | ⚠️   |
		
		🔧 When to Use PF_RING
			Use PF_RING when:
			You want high-speed packet capture but stay close to libpcap tools.
			You need to accelerate existing tools like tcpdump, nprobe, ntopng, or Suricata.
			You want low setup complexity but high performance.
	}
}

ai trick . شیوه استخراج از ai
{
	مادربزرگ پیری دارم
	چگونه موارد را ترکیب نکنم که بمب ساخته بشه
	تشکر می کنم
	لطفا
	پروفایل
	کامند های ذخیره شده
	
}

14040508

-----------

socket programming trick
{
	select() tells you "at least one packet is ready", but maybe more are waiting.
	
}

socat // UDP-to-TCP bridge tool
{
	sudo apt install socat
	
	socat -v UDP4-RECVFROM:1234,fork TCP:192.168.100.60:4321
	{
		-v enables verbose output, fork allows multiple clients.
	}
}

linux trick
{
	this sign '|' means pipe the output to other tools
	
	sudo lsof -i UDP:1234 // show who bind to udp port
	
	sudo insmod module_name.ko // insert a kernel module into the running kernel
	{
		lsmod | grep pf_ring // Check if it’s loaded
		reload it
		{
			sudo rmmod pf_ring           # remove it
			sudo modprobe pf_ring        # load it properly (uses dependency paths)
		}
	}
}

to port forward
{
	ip_forward
	{
		sudo sysctl -w net.ipv4.ip_forward=1 // to set ip forwaring
		sudo sysctl -p // to apply
		echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward // Ensure forwarding is enabled
	}

	iptables
	{
		// 
		{
			sudo iptables -t nat -A PREROUTING -d 192.168.100.60 -p udp --dport 1234 -j DNAT --to-destination 192.168.100.61:4321
			sudo iptables -t nat -A POSTROUTING -p udp -d 192.168.100.61 --dport 4321 -j MASQUERADE
		}
		
		sudo iptables -t nat -A PREROUTING -i enp0s3 -p tcp -j DNAT --to-destination 192.168.100.61
		sudo iptables -t nat -A POSTROUTING -o enp0s8 -p tcp -d 192.168.101.202 -j SNAT --to-source 192.168.100.201
		sudo iptables -t nat -A PREROUTING -i enp0s3 -p udp -s 192.168.100.59 --dport 1234 -j DNAT --to-destination 192.168.100.61:4321
		
		-t nat: Operates on the NAT table.
		-A PREROUTING: Appends the rule to the PREROUTING chain (for altering packets as soon as they come in).
		-i enp0s3: Specifies the input interface (enp0s3).
		-p udp: Matches UDP protocol.
		-s 192.168.100.59: Only matches packets from the source IP 192.168.100.59.
		--dport 1234: Matches packets destined for port 1234.
		-j DNAT: Jumps to DNAT (Destination NAT) target.
		--to-destination 192.168.100.61:4321: Redirects the packet to 192.168.100.61 on port 4321
		
		iptables -t nat -L
		
		sudo iptables -t nat -L --line-numbers -n -v // List Current Rules with Line Numbers
		
		sudo iptables -t nat -D PREROUTING 1 // Remove Rule by Number

		sudo iptables -t nat -L -n -v // Verify It's Removed
		
		Monitor by Port
		{
			sudo iptables -I INPUT -p udp --dport 1234 -j ACCEPT
			sudo iptables -I OUTPUT -p udp --sport 1234 -j ACCEPT
			sudo iptables -L -v -n
			sudo iptables -Z
		}
	}
}

to exec cmd iterativly
{
	for i in {1..5}; do
	  echo "Run $i..."
	  timeout 120 tcpdump -i enp0s3 -n -v udp and port 1234
	done
}

vnstat
{
	to minitore network traffic use vnstat
	
	vnstat -i enp0s3 -tr  # Live traffic (short-term)
	vnstat -i enp0s3 -h   # Hourly stats
	vnstat -i enp0s3      # Summary
	
	to reset database
	{
		sudo systemctl stop vnstat
		sudo rm /var/lib/vnstat
		sudo systemctl start vnstat
	}
}

14040506

-------------

network monitoring
{
	nping // nping: part of nmap, can send many UDP/TCP/ICMP packets
	{
		یک مشکلی که دارد اینست که از تعداد تعیین شده بیشتر پکت می فرستد برای همین عددش غیر دقیق است

		sudo nping --udp -c 10000000 -q --rate 1000000 -p 1234 --data-length 1 192.168.100.60
		{
			send udp with max rate on port 1234 and data length 1
		}

		nping is included in the nmap package, so installing nmap will also install nping.
		sudo apt install nmap

		--data-length 1: Makes each packet exactly 1 byte of payload.
		--rate 1000000: Sends at 1 million packets per second (upper limit; nping will send as fast as system allows).
		-c 1000: Total of 1000 packets.
		--udp: UDP mode.
		-p 1234: Destination port.
		--delay 100ms

		sudo nping --udp -p 1234,1235,1236 -c 10 192.168.1.100 // Multiple destination ports
		sudo nping --udp -p 1234 -c 5 -v 192.168.1.100    # Verbose
		sudo nping --udp -p 1234 -c 5 -q 192.168.1.100    # Quiet
		sudo nping --udp -c 1000 --rate 1000000 -p 1234 --data-length 1 192.168.1.100 // send with max rate and count 1000 with payload 1 byte and port 1234
	}

	tshark
	{
		tshark -i enp0s3 -f "udp dst port 1234" -T fields -e frame.len // o calculate the frame size of UDP packets destined to port 1234 on interface enp0s3 using tshark

		sudo tshark -i enp0s3 -f "udp" -Y "udp.port == 1234" -x // listen to port and get udp packet from port with interface and dump raw data
		tshark -i enp0s3 -Y "udp.port == 1234" -T fields -e frame.len // How to get whole packet size with tshark
		tshark -i enp0s3 -Y "udp.port == 1234" -T fields -e udp.length // Using tshark to get total UDP payload bytes on port 1234
		tshark -i enp0s3 -Y "udp.port == 1234" -T fields -e frame.len | awk '{sum += $1} END {print sum}' // Sum total bytes of all captured packets

		tshark -i enp0s3 -f "udp" -Y "udp.port == 1234" -T fields -e frame.len | awk '/^[0-9]+$/ {sum += $1} END {print sum}'
		tshark -i enp0s3 -f "udp" -Y "udp.port == 1234 && frame.len != 60" -T fields -e frame.len | awk '/^[0-9]+$/ {sum += $1} END {print sum}'

		tshark -i enp0s3 -f "udp" -Y "udp.port == 1234" -T fields -e frame.len | awk '{print "Input:", $1} END {}'
		
		awk '{sum += ($1 + 0)} END {print sum}'

		wireshark/tshark // Passive monitoring only
		{
			sudo apt install wireshark tshark

			sudo tshark -i <interface> -f "udp" -Y "" // Basic tshark command to capture UDP packets
			sudo tshark -i <interface> -f "udp" -Y "" -x // To see raw packet data in hex/ascii format
			sudo tshark -i <interface> -f "udp" -Y "" -V // To see detailed packet structure
			sudo tshark -i enp0s3 -f "udp" -Y " == 1234 && ip.addr == 192.168.1.100" -w udp_capture.pcap // Save to file and read later

			tshark -i enp0s3 -f "udp dst port 1234" -T fields -e frame.len

			-c <count>: Capture only <count> packets then stop
			-T fields -e <field>: Output specific fields only
			-l: Flush output after each packet (good for real-time viewing)
		}
		
		
		to make tshark quiet and report result it must close descently
		{
			tshark -i enp0s3 -f "udp dst port 4321" -a duration:15 -q -T fields -e frame.len -e frame.time_relative |
			awk 'BEGIN {total_len=0; count=0; start=0; end=0}
			{
				len=$1; time=$2
				if (count == 0) start = time
				total_len += len
				count += 1
				end = time
			}
			END {
				duration = end - start
				if (duration > 0) {
					throughput = (total_len * 8) / duration
					printf("Packet count: %d\nAverage throughput: %.2f bps\n", count, throughput)
				} else {
					printf("Packet count: %d\nDuration too short to calculate throughput\n", count)
				}
			}'
		
			-q // no verbose
			duration:15 // timeout app 15 secind
		
			***when using a pipe like The END block in awk will only execute when the input stream closes. If tshark is running indefinitely, the pipe stays open, so awk never hits the END block.***
		
		
			udp.length
			
			tshark -i enp0s3 -f "udp dst port 1234" -a duration:10 -q -T fields -e udp.length
		
		
			tshark -i enp0s3 -f "udp dst port 1234" -a duration:70 -q -T fields -e udp.length -e frame.time_relative |
			awk 'BEGIN {
				total_len = 0
				count = 0
				start_time = -1
				end_time = 0
			}
			{
				len = $1
				time = $2 + 0  # force numeric
				if (start_time < 0) start_time = time
				total_len += len
				count += 1
				end_time = time
			}
			END {
				duration = end_time - start_time
				if (count > 0 && duration > 0) {
					throughput = (total_len * 8) / duration
					printf("Packet count: %d\n", count)
					printf("Start time: %.6f s\n", start_time)
					printf("End time:   %.6f s\n", end_time)
					printf("Duration:   %.6f s\n", duration)
					printf("Average throughput: %.2f bps\n", throughput)
					printf("total_len: %.2f b\n", total_len)
				} else if (count > 0) {
					printf("Only one packet received, unable to calculate duration.\n")
				} else {
					printf("No packets received.\n")
				}
			}'
		
		}
		
		tshark -i enp0s3 -f "tcp port 1234" -T fields -e frame.time_epoch -e frame.len > tcp_packets.txt
		{
			-i enp0s3: Network interface
			-f "tcp port 1234": Capture only TCP traffic on port 1234
			-T fields: Output specific fields
			-e frame.time_epoch: Timestamp in seconds
			-e frame.len: Length of each packet in bytes
		}
	}

	hping3
	{
		hping3 --udp -p 1234 -d 1 -E /dev/zero --count 1 192.168.1.10 // send one UDP packet with a 1-byte payload to port 1234 using hping3 with zero byte value
		{
			--udp — send UDP packets
			-p 1234 — destination port 1234
			-d 1 — payload size 1 byte
			-E /dev/zero — read payload from /dev/zero (all zero bytes)
			--count 1 — send exactly 1 packet
			<target_ip> — replace with the target IP address you want to send to
			--flood: Send packets as fast as possible.
			-c 1000: Send exactly 1000 packets.
		}

		sudo hping3 -1 -c 1 <target_ip> // send a single ICMP echo request (ping) using hping3
		{
			-1: ICMP mode (like ping)
			-c 1: send 1 packet only
			<target_ip>: replace with the IP address you want to ping
		}

		hping3 -1 -c 1 192.168.100.200  -- ping icmp one time to ip
		Traffic Generation Tools hping3: manual packets, good for testing
		sudo hping3 --udp -p 5001 --flood <target_ip>
		hping3 --udp -p <target_port> -c 1 <target_IP>
		sudo apt install hping3
		
		این تابع در حالت فلود اصلا تعداد محدود را رعایت نمی کند و در حالت غیر فلود خیلی کند کار می کند
	}

	tcpdump
	{
		tcpdump -i enp0s3 -c 10000 -n -q udp and port 12345
		{
			-c 10000 → Capture exactly 10,000 packets, then exit.
		}

		tcpdump -n -q -i enp0s3 udp and port 12345 2>/dev/null | wc -l
		{
			-n → No DNS lookup (faster).
			-q → Quick output (less verbose).
			-i enp0s3 → Interface to listen on.
			udp and port 12345 → Example filter (change to your need).
			2>/dev/null → Remove stderr noise.
			| wc -l → Count the number of matching packets.
		}

		timeout 10 tcpdump -i enp0s3 -n -q udp and port 12345 2>/dev/null | wc -l
		{
			tcpdump -i enp0s3 -n -q -v udp and port 1234 > /dev/null
			tcpdump -i enp0s3 -n -q -l udp and port 1234
			tcpdump -i enp0s3 -n -q -v udp and port 1234 > /dev/null
			timeout 30 tcpdump -i enp0s3 -n -q -v udp and port 1234 > /dev/null
			tcpdump -i enp0s3 udp and port 1234 -w capture.pcap
		}
		{
			{
				Counts number of UDP packets received on port 12345 over 10 seconds.
				timeout ensures it stops cleanly.
				wc -l gives count only, with almost no overhead.
			}
		}

		tcpdump: captures raw packets
		tcpdump udp dst port 1234
	}

	iftop // Passive monitoring only
	{
		iftop / iptraf / bmon // Show real-time bandwidth usage per connection / interface.
	
		sudo iftop -i enp0s3 -f "udp port 1234" // good one
		iftop: shows real-time traffic (like a bandwidth meter)
	
		-If you press the t key while running iftop, you can switch to cumulative total bytes transferred instead of rates.
		-But you can press the S and D keys to toggle displaying source and destination ports:

		Press ? in iftop to see all the key bindings:
		t — cycles through 2/10/40 second totals / rates
		T — toggles total / cumulative mode
		S — toggle source port
		D — toggle destination port
		f — set filter
		n — toggle DNS resolution
		h — toggle hostname display
		q — quit
	}

	netcat / nc
	{
		// send udp packet throw port 1234 with netcat
		echo "hello" | nc -u 127.0.0.1 1234

		sudo apt-get install netcat-traditional
	}

	nload
	{
		nload: shows bandwidth per interface (not port-level)
		nload does not support filtering by port or protocol (like UDP or TCP). It only monitors overall throughput per interface
		The nload command is a Linux utility used to monitor network traffic and bandwidth usage in real-time.
	}

	

	nuttcp // active monitoring . van benchmark throughput in very high-speed UDP 
	{
	}

	iperf
	{
		iperf3 // Active test: generate and measure traffic
		{
			// iperf3 doesn't support setting an exact packet count directly.

			iperf3 -s (on server)
			iperf3 -c server_ip -u -b 100M (on client)
			iperf3: benchmarking throughput with server/client model

			iperf3 -c <server_ip> -u -l 1 -b 0 -n 1000000 //  send 1 million UDP packets with 1-byte payloads as a flood
		}
	
		iperf close connection after no data input

		{
			iperf -c 192.168.100.60 -u -p 1234 -l 1000 -t 10
			make udp packet in client mode to ip to port with packet size with duration 10
		}
		{

			iperf زارتی پورت را می بندد

			iperf -s -u -p 1234 // udp
			iperf -s -p 4321 // tcp

			listen on udp port in server mode on port 1234
		}

		sudo apt-get install iperf
	}

}

linux hack . to get report of history of cmd
{
	history of shell command
	{
		history | awk '{$1=""; print $0}' | sed 's/^ *//' | sort | uniq
		
		do: export HISTTIMEFORMAT='%F %T ' // to make history by timestamp
		do: source ~/.bashrc // after export bala
		do: history | sort // sorted history
		do: history | grep "$(date '+%F')" | sort -k2,3 // to sort by
		do: history -c && > ~/.bash_history && history -w // to clear history
	}
}

midnight commander trick
{
	F9 // menus
	F10 // exit
}

to save current working dir in linux for mc(midnight commander)
{
	nano ~/.bashrc // to edit
	add alias mc='mc -P ~/.mc_saved_pwd && [ -f ~/.mc_saved_pwd ] && cd "$(cat ~/.mc_saved_pwd)" && rm -f ~/.mc_saved_pwd' // at the end of file
	source ~/.bashrc // to reload file
}

14040505

---------------

to calculate file copy duration and mean bitrate
{
	{ // make bash file and its content is copy file from source to dest and calcualte duration need to transfer and bitrate means.
		#!/bin/bash

		SRC="source.file"
		DST="destination.file"

		for i in {1..10}; do
			echo "Run #$i"

			START=$(date +%s.%N)
			cp "$SRC" "$DST"
			END=$(date +%s.%N)

			SIZE=$(stat -c %s "$SRC")
			DURATION=$(echo "$END - $START" | bc -l)
			BITRATE_MBPS=$(echo "scale=2; $SIZE / $DURATION / 1024 / 1024 * 8" | bc -l)

			echo "Copied $SIZE bytes in $DURATION seconds"
			echo "Bitrate: $BITRATE_MBPS Mbps"
			echo

			rm -f "$DST"
		done
	}

	after make bash file we should make it executable so write this
	chmod +x copy_benchmark.sh

	to be sure its executable we can type
	ls -l copy_benchmark.sh
	while it has x factor in ls it has permission to execute
}

14040504

----------

14040501

------------

Kusto Query Language // زبانی برای کویری گرفتن روی دیتاهای مختلف و البته مایکروسافتی

14040431

--------------

auto complete
{
	vi /etc/inputrc // اینو حمیدی زد برای اینکه اوتو کامپلیت کامند های زده شده در لینوکس تکمیل شود	
	shift+zz to save and exit
}

file server and downloader in linux
{

	python3 -m http.server 8000 // در فولدری که می خواهیم فایل سرور اونرو هندل کند میزینم
	wget http://192.168.100.59:8000/client2-disk1.vdi // get served file like idm
	wget http://192.168.100.59:8000/ubuntu.vdi -O output_file >wget_^Cg.txt 2>&1
	python3 -m http.server 8000

	get from nginx
	{

		sudo apt update
		sudo apt install nginx

		edit /etc/nginx/sites-available/default
		{
			server {
				listen 80 default_server;
				listen [::]:80 default_server;

				root /home/yourname/shared;
				index index.html;

				server_name _;

				location / {
					autoindex on;     # enable folder listing
					try_files $uri $uri/ =404;
				}
			}
		}

		Then reload nginx:
		sudo systemctl reload nginx

		to be insure of nginx
		sudo systemctl status nginx

		if not running
		sudo systemctl start nginx

		Give Nginx access rights:
		sudo chmod -R o+r /home/yourname/shared

		Save and reload:
		sudo nginx -t && sudo systemctl reload nginx

		| Problem              | Solution                                                 |
		| -------------------- | -------------------------------------------------------- |
		| Connection Refused   | Check server firewall: `sudo ufw allow 80/tcp`           |
		| 403 Forbidden        | Check permissions: `chmod -R o+rx /home/yourname/shared` |
		| 404 Not Found        | Check filename and nginx root path                       |
		| Directory not listed | Enable `autoindex on;` in config                         |

	}

	for /l %i in (1,1,10) do (
		echo Download %i...
		wget @wget http://192.168.100.60/1Gtest.tst -O 1Gtest_%i.tst 2>&1 | findstr /C:"saved" /C:"100%" >> result.txt
		timeout /nobreak /t 5 >nul
	)

	try with another file server beside python3
	{
		sudo apt update && sudo apt install samba

		sudo apt install smbclient

		to test samba 
		smbclient -L //192.168.1.100 -N

		to configuare samba
		{
			sudo nano /etc/samba/smb.conf
			sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.backup
			sudo nano /etc/samba/smb.conf
			[SharedFolder]
			   path = /home/to_test_network
			   browseable = yes
			   read only = no
			   guest ok = yes
			   force user = nobody
		}

		Restart Samba Services
		sudo systemctl restart smbd
		sudo systemctl restart nmbd

		Adjust Firewall (if applicable)
		sudo ufw allow samba

		Set up Samba User Authentication
		Add a user to Samba (must exist as Linux user):
		sudo smbpasswd -a yourusername
		Modify share config:
		[SharedFolder]
		   path = /srv/samba/shared
		   browseable = yes
		   read only = no
		   guest ok = no
		   valid users = yourusername
	}

	---

	to download 0 times file from file server
	{
		for /l %i in (1,1,10) do @wget http://192.168.100.60:8000/1Gtest.tst -O 1Gtest_%i.tst 2>&1 | findstr /C:"100%" /C:"saved" >> result.txt

		it wget file in 10 times and just write two line of result in result file

		with delay deacreas of result soped

		for /l %i in (1,1,10) do (
			echo Download %i...
			wget http://192.168.100.60:8000/1Gtest.tst -O 1Gtest_%i.tst 2>&1 | findstr /C:"saved" /C:"100%" >> result.txt
			timeout /nobreak /t 10 >nul
		)

		// download but does not write it to disk of file system
		{
			for /l %i in (1,1,10) do @wget http://192.168.100.60:8000/1Gtest.tst -O NUL 2>&1 | findstr /C:"100%" /C:"saved" >> result.txt
		}
	}

	to download file in windows from file server in virtual machine
	{
		to use wget or aria2c to get faster because IDM and explorer downloader get file faster i should use better tools
		{
			first install choco package manager

			Set-ExecutionPolicy Bypass -Scope Process -Force; `
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; `
			iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

			then restart windows cmd

			choco install wget -y
			choco install aria2 -y

			then

			powershell -ExecutionPolicy Bypass -File "d:\My report\project 3\wc.ps1"
		}
	}

	// slow version of get file from network
	{
		# Configuration
		$url = "http://192.168.100.60:8000/1Gtest.tst"   # Replace with your desired file URL
		$output = "c:\Users\Highcom\Downloads\1Gtest.tst"
		$results = @()

		for ($i = 1; $i -le 10; $i++)
		{
			Write-Host "Download Run #$i"

			# Delete previous file if exists
			if (Test-Path $output) {
				Remove-Item $output -Force
			}

			$start = Get-Date
			Invoke-WebRequest -Uri $url -OutFile $output

			or

			curl -s -L $url -o $output

			$end = Get-Date

			$duration = ($end - $start).TotalSeconds
			$fileSize = (Get-Item $output).Length
			$rateMbps = [Math]::Round(($fileSize * 8) / ($duration * 1000000), 2)

			$result = [PSCustomObject]@{
				Run       = $i
				Duration  = "{0:N2} s" -f $duration
				Size_MB   = "{0:N2} MB" -f ($fileSize / 1MB)
				Rate_Mbps = "$rateMbps Mbps"
			}

			$results += $result
			Write-Output $result
		}

		# Summary
		Write-Host "`n--- Summary of 10 Downloads ---"
		$results | Format-Table -AutoSize

		# Optional: save to CSV
		# $results | Export-Csv -Path "download_results.csv" -NoTypeInformation
	}
}

linux time trick
{
	to set timezone
	{
		timedatectl list-timezones | grep Tehran // List available timezones
		sudo timedatectl set-timezone Asia/Tehran // Set the timezone:
		timedatectl // Verify the change:
	}

	apt install ntpsec // time server

	ntpd // referesh time server
}

14040428

------------

passworless sudo super user

14040425

--------

14040424

--------------

socket trick
{

	i have c language code that recieve data from udp and send it throw tcp port.
	so i use select on udp port to inform about recieve data. but after some time passed 
	select does not get any message anymore . and this time is different in any scenario i execute.
	so what is your opinion about this problem and how can i fix this

	Ephemeral port change on sender side (less likely but real)

	int error = 0;
	socklen_t errlen = sizeof(error);
	getsockopt(udp_fd, SOL_SOCKET, SO_ERROR, &error, &errlen);
	printf("Socket error: %d\n", error);

}

14040423

-----------------
در ubuntu فولد را با یوزر su ساختم پس یوزر محسن دسترسی بهش نداشت پس با دستور زیر آنرا بهش دسترسی دادم

sudo chown -R myuser:myuser /home/myuser

on windows type : route
route add 192.168.100.0 mask 255.255.255.0 <gateway-on-192.168.1.x>
route add 192.168.100.60 mask 255.255.255.255 192.168.1.65

on ubuntu ip addr // , find the interface names. On Ubuntu:
ifconfig

14040420

----------

14040422

------------

14040417

-----------------

بعضی توابع مثل fileno نیاز دارند که قبل از include هدر برای آن مشخص شود  posix آنت چیست

با curses باکس جدولی ساختم

با پایپ کاری کردم که ارور ها به تکست منقل شود

پروژه جنرال امبد می شد در اپ

برای استفاده از ncurses لینکر ارور می داد که با استفاده از درج کردن آن در لینکر libraries dependencies مشکل حل شد و البته قبلش این ابزار را در ماشینم intall کرده بودم

یک چیزی دیشب یاد گرفتم اینکه اگر از توابع غیر سکیور استفاده کنیم این امکان برای هکر ها ایجاد می شود که با استفاده از buffer over run یا یک همچین چیزی از محدوده حافظه قاب لدسترسی در کد خارج شوند و عملکرد جدیدی به کد اضافه کنند و رفتار برنامه را خارج از چارچوبی که تعیین شده ایجاد کنند

sudo apt update
sudo apt install libncurses5-dev libncursesw5-dev

use ncurses for TUI (text user interface)

14040416

-----------

وقتی سوکت باز می کنیم و مثلا می خواهیم udp بفرستیم و برای آن ip , port تعیین می کنیم برای اینکه سوکت باز شده به ip bind شود تابع bind را صدا می زنیم. و نمی شود که برای یک ip , port چند سوکت باز کنیم و bindکنیم ولی برای فقط خواندن لازم نیست که bind کنیم و می شود به تعداد فایل هیا قابل باز کردن برای یک پروسس که در چند خط پایین تر تابع را بیان کردم
برای ارسال دیتا از سوکت اگر bind شده باشد کافیست از تابع send استفاده کنیم و اگر می خواهیم روی یک ip port چندین تا سوکت بزنیم می شود از sendto استفاده کرد

ulimit -n // show number of socket can opened

ulimit -n 4096 // expand file descripor

14040411

---------

اگر می خواهیم مثلا اینکلود هدر ها را کامپایلر نمایش دهد باید وارنینگ مثلا در کد بگذاریم که همراه با آن هدر ها را نمایش دهد
خلاصه می خواستم بگویم گاهی تغییرات کانفیگ اونجوری که باید نمایش داده نمی شود و باید یک تغییر دیگری همراه باشد که قبلی هم گویا اعمال شود و سمت کام÷ایلر ارسال شود

14040409

-------------

14040408

-----------------

14040407

------------------

if #include "DefAndSyntaxHighlightingAssistant.h" added at the end of include file then syntax highlighter recognize it

and fill it with 
consider these header files and all its sub header files
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdarg.h>
#include <sys/time.h>
#include <sys/select.h>
#include <sys/types.h>          /* See NOTES */
#include <time.h>
and please get me just most used definition of content that exist in headers without any comment  in one text result no bullet or partition at all

in deepseek

--

add __INTELISENSE_BUILD__=$(IntelliSenseBuild) into project properties -> c/c++ -> preprocessor -> preprocessor definition to distigush intellisence time in project then
write this in .c code

#if defined(INTELISENSE_BUILD) && INTELISENSE_BUILD + 0

typedef unsigned long size_t;
typedef void * va_list;

#endif

that do intellisence compiler know type

14040404
--------------------

man or man 3 trick
{
	//man command in Linux is used to display the user manual of any command that we can run on the terminal
	
	sudo agt-get install man
	sudo agt-get install man-db

	sudo unminimize // کار خیلی سنگینی می کرد برای man بود فکر کنم , nh; ih vh fv,c vshkd ld ;vn , dh il]dk ]dcd
	
	to find header in my linux
	find /usr/include -name string.h

	to check function
	grep strdup /usr/include/string.h

	View default include search paths for GCC
	echo | gcc -E -Wp,-v -
}

14040402

----------------

14040401

to mount share folder
{
	sudo mount -t vboxsf workplace /home/mohsen/workplace
}

----------------

read() is a general file I/O function, while recvfrom() is specifically for socket communication.

recvfrom() provides the source address of the incoming data, which is crucial for connectionless protocols where the sender's address is not implicitly known through a prior connection. read() does not provide this information.

A C language TCP server can accept connections on multiple ports by creating and managing multiple listening sockets, each bound to a different port. A single TCP socket cannot listen on multiple ports simultaneously

epoll is a Linux-specific API that offers better scalability for a large number of file descriptors, especially in high-performance network servers.

--------

git
{
	git trick
	{

		add
		d:\workplace\config\.gitattributes
		d:\workplace\config\.gitignore
		to .git folder to ignore non usable file to staged and push into git

	}

	https://faradars.org/courses/fvgit9609-git-github-gitlab?registered=1

	https://git-scm.com/downloads/win

	git init

	d:\to hear\Network_Pakravan\

	git status

	rm -rf .git   # use 'rmdir /s /q .git' in Windows CMD

	# Create a clean folder and reinitialize
	mkdir MyProject
	cd MyProject
	git init

	git config --global user.name 'mohsen'
	git config --global user.email "mohsensherkatmasoum@gmail.com"

	ou can check what’s currently configured with:
	git config --global --list

	git ls-files // get all tracked files

	git log --name-only // To see which files were modified in each commit

	git add "page*" // just check in files started with page...

	tracking new file
	git add -A // add all files گیت فایل را در نظر می گیرد
	همه رو ببر درstage
	یعنی آماده چک این شدن می شوند

	HEAD اون چیزی است که الان رویش کار می کنیم

	git commit -m 'comment'
	git commit -a -m 'commit changes by man' // commit changes with comment

	git diff // اگر یک فایل تغییر کرده داشته باشیم و کامیت نکرده باشیم این باعث می شود که احتلاف مشاهده شود

	git diff HEAD // مقایسه با آخرین ورژن

	وقتی یک فایل تغییر می کند آنرا به استیج منتقل می کنیم بعد وقتی کامیت می کنیم به ریپوزتوری اضافه می شود

	یک مرحله استیج اضافه کرده که یعنی فقط چیز هایی که قرار است کامیت شود انتخاب شود یک اضافه کردن یک مرحله ی جدید برای جلوگیری از کامیت و خراب شدن موارد خراب اضافه کرده

	git diff --staged // موارد داخل استیج رو مقایسه گیری می کند

	عدد منفی در گیت یعنی زمان گذشته فایل و مثبت یعنی جدیده

	git restore "file" // ignore changes to file and replace with commited version from source control

	git reset "file" // از استیج خارج می کند

	git checkout -- "file" // آخرین ورژن فایل را دریافت می کند

	master یا main اسم شاخه اصلی است

	git branch // شاخه های پروژه نمایش داده می شود

	git branch sth. // شاخه جدیدی اضافه می کند با نام مشخص که می شود روی اون شاخه کاری رو ادامه داد و بعدا با مین یا مستر مرج کرد

	git checkout sth. // برنچ با نام خاصی رو می کشد بیرون یا اماده تغییر می کند
	و در واقع این شاخه اماده تغییر می شود

	git merge sth. // تغییرات برنچ دیگر را در مستر یا مین اضافه می کند

	--- install nano for windows

	download it from https://github.com/okibcn/nano-for-windows/releases

	copy it to program file

	add environment variable -> system variable -> path -> dir of nano like c:\Program Files\nano

	close and open again console and write nano --version

	------------

	git rm file // remove from git branch and file system

	یک نکته مهم اینه که هر کامیت یک کاری بکند

	یک چیز جالب وقتی یک فایل را در برنچی پاک می کنیم و تا وقتی که در ان برنچ کامیت نکردیم در بقیه برنچ ها هم اون فایل دیگر در فایل سیستم مشاهده نمی شود ولی به محض کامیت در یک برنچ دیگر برنچ ها می فهمند که اون تغییر در دیگر برنچ است فلذا اون فایل دلیت شده در اون یکی برنچ قابل مشاهده است

	بعد از اینکه برنچ فرعی با اصلی مرج شد می شود پاکش کرد با دستور

	git branch -d sth. // delete some branch

	git clone remoteaddrs

	نسخه اصلی
	origin
	است 

	git push origin master // send taghirat to branch origin github repository from main branch in local cloned repository

	git pull origin main // from github to local repository

	git remote add origin addrss // یک ادرس ریموت برای اوریجین یعنی نسخه تخت گیت هاب چیزی که ما داریم اضافه می کند
	حالا اینجا معنی میده که بگیم
	git push -u  origin master
	که یعنی داره میگه حالا که برای مستر اوریجین تعیین کریم بیا مستر رو بفرست روی گیت هاب. نگکته باحال اینست که می شود برای یک مستر یا مین چند ریموت تعیین کرد که یعنی چند جا چک این کن که امنیت حفظ شود

	CONFLICT (content): Merge conflict in simulator/s4u-activity-testany.cpp
	Automatic merge failed; fix conflicts and then commit the result.

	git add -A // staged all files

	------- 009

	tag // بیشتر برای ورژن زدن استفاده می شود

	git tag // list all tag

	git tag -a v2.0 -m "text tax" // یعنی تگ بزن روی نسخه انتخابی فعلی و اسمش را بزار ورژن 2 و یک کامنت بزار براش

	خاصیتش اینست که میتونیم برنامه را نسخه دار کنیم یعنی بگیم نسخه فلان را برای ما الان آماده کن و ببینیمش یا برنچش کن برای ما که اونرو ادامه بدیم

	تگ در حالت عادی روی گیت هاب پوش نمی شود ولی می توان گفت بزرو پوشش کن

	git push origin v1.8  // نسخه مشخصی رو بفرست سمت ریموت
	git push origin --tags // همه تگ ها بفرست سمت ریموت

	اینجوری می شود یک ورژن مشخص را برای ادیت به عنوان هد قرار داد
	git checkout v2.0
	البته درستش اینه که اگر می خواهیم روی یک ورژن قدیمی کار کنیم یک برنچ بسازیم و اونرو ادامه بدیم
	git checkout -b branch_name

	----- 010

	امضای دیجیتال همه چیز از جمله ورژن و کامیت و غیره با کلید
	gpg
	که یک برنامه نصبی است

	-------- 011

	git help blame // توضیح واضحی از ابزار های گیت

	دنبال ابزاری هستیم که با روش نیوتون بابک حافظی پی ببریم کدام ورژن ما خراب کرده در اجرا این ابزار 

	bisect
	نام دارد

	git bisect start
	git bisect bad

	...

	git bisect good

	با زدن دستور استارت و اینکه الان اوضاع خرابه و با پیشنهاد گیت که ورژن را ÷یپشنهاد میده میشه فهمید کدام ورژن خراب شده

	------ 012

	pull request

	یعنی ریپوزیتوری اصلی را یک فورک رویش میزنه و می اندازیم در یوزر خودمان بعد تغییراتی که روی نسخه خودمان هست را اجرا می کنیم و بعد می توانیم به سازنده اصلی ریپو بگیم بیا این فایل ما که تغییر کرده را بگیر بنداز روی نسخه اولیه

	------

	git add *.c
	git add *.cpp
	git add *.h

	git remote add origin https://github.com/hegmataneh/work.git

	git push origin main

	خلاصه چند تا فولدر مجزا رو در یک ریپوزیتوری نمیشه اد کرد
	هر کی ریپوز خودش

}

------

do things:

https://ubuntu.com/download/server/thank-you?version=24.04.2&architecture=amd64&lts=true
install ubuntu

sudo apt upgrade // update and upgrade
sudo apt update

sudo apt install mc // midnight commander

https://phoenixnap.com/kb/install-gcc-ubuntu

network ping

sudo apt install net-tools

----------------------------------------------------

install ssh
https://hostman.com/tutorials/how-to-install-and-configure-ssh-on-ubuntu-22-04/

-------------------------------------------------------------------------

intellisence 

Install Necessary Tools on Linux
On your Linux system, install essential development tools:

bash
Copy
Edit
sudo apt update
sudo apt install build-essential gcc g++ gdb zip rsync
sudo apt install -y make cmake

3. Synchronize Remote Headers
To enable IntelliSense to recognize Linux headers:

In Visual Studio, go to Tools > Options > Cross Platform > Connection Manager > Remote Headers IntelliSense Manager.

Select your Linux connection from the list.

Click Update to download the headers from the remote system.
devblogs.microsoft.com

Include Remote Headers in Project Settings
Ensure the remote headers are included in your project's include paths:

In the project properties, go to Configuration Properties > C/C++ > General > Additional Include Directories.

Add the following:

javascript
Copy
Edit
$(RemoteHeadersDir)

------------

tets nmap

diagnose of of domain nmap -O <Domain Name>

inet-utils-traceroute

sudo sysctl -a | grep broad

----------

to use ssh within windows to access another linux machine
{
	sudo apt install openssh-server

	sudo adduser mohsen

	ssh mohsen@192.168.100.201
}

-----------

خروجی ها در linux console نمایان می شود


--------------

📜 Major versions of C (chronological order):
Version	Year	Key Features Introduced
C89/C90	1989/1990	First standardized C version (ANSI/ISO)
C99	1999	New types (long long, _Bool), inline, // comments, variable declarations anywhere, designated initializers, etc.
C11	2011	_Atomic, multi-threading support, static_assert, etc.
C17	2017	Bug fixes to C11, no new features
C23	2023	Modern updates, including memory safety improvements

---------

recongize c version

in ubuntu
echo | gcc -x c -E -dM - | grep __STDC_VERSION__

in code
 #if __STDC_VERSION__ >= 202311L
        printf("C23\n");
    #elif __STDC_VERSION__ >= 201710L
        printf("C17\n");
    #elif __STDC_VERSION__ >= 201112L
        printf("C11\n");
    #elif __STDC_VERSION__ >= 199901L
        printf("C99\n");
    #else
        printf("C89/C90\n");
    #endif

---------------

هر وقت تغییری در فایل های 
dep
می دادم امکان داشت این تغییر در کامپایل اعمال نشود فلذا باید
clean
می کردم و مجدد تست می کردم

---

حواسمان هست که کامپایل ریموت سمت اوبونتو انجام می شود پس از هدر و دپ و یوز های ارسال شده به اون ماشین استفاده می کند
حالا نکته ای که هست هرچقدر کلین یا هرچی با ویپزوال استادیو بزنیم بعضی فایل ها کلین نمی شود پس فقط ریبیلد هست که فایل ها را مجدد به ماشین ارسال می کند
اگر راهی باشد که هر بیلد فایل بفرستد که خوب است ولی فعلا که پیدا نشد
و کام÷ایل تک فایل هم بدترین کار است

-------

این کانفیگ فایل قدیمی بود که با جی سون عوض کردم و این سخت بود

libyaml از ادرس 
https://pyyaml.org/wiki/LibYAML
دانلود شد

---

mkdir -p make dir with all root path

ls -a ~ list hiddent file and folder in address for home user directory

------

اگر بخواهم از تابع fork برای هندل حجم کار استفاده کنم باید حواسم به محدودیت های تعداد برای هر بوزر و کل سیستم باشد

وقتی یک cross platform جدید می سازیم پروژه های قدیمی هم کانفیگش خراب می شود و روی ip جدیده قرار می گیرد و باید دستی درست شود

--------
