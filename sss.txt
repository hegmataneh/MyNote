

اگر بخواهم خلاصه توضیح بدهم چکار کردم، کارم بدین شرح است

اول یک circular buf لاک نشونده داریم برای pcap ها که قسمت نوشتنش اصلا لاک نمی شود و می نویسد و می رود جلو
قسمت خواننده این مموری که اسمش را گذاشتم fast و باید نوشتنش خیلی سریع باشد و خواندنش هم با کمترین معطلی پکت ها را از این بافر بر دارد.


پکت های ریخته شده در بافر سریع و کم حجم توسط قسمت defragmentator ام به ارسال کننده منتقل می شود و این قسمت سعی می کند پکت را در صورت لزوم سرهم کند

بعد پکت های سالم برای یک قسمت دیگر ارسال می شود با نام packet mgr که مسئول اینست که یک بافر بزرگ فراهم کند و با سرعت نه به اندازه بافر قبلی ولی همچنان سریع موارد را ذخیره کند. اینکار را هم با استفاده از circular link list انجام می دهد و هر قسمت که بهش می گویم segment حافظه 2 مگی دارد برای همه وقتی یکبار الوکیت شود برای پکت های جدید دیگر بدون معطلی می تواند موارد را دریافت کند بنابر این بافر قسمت قبلی که گفتم را سریع کپی می کند روی خودش. 
اونجایی هم که تصمیم می گیرد مثلا راند رابین و یا replicate ای پکت را بفرستد سمت tcp در واقع همین قسمت است که مثلا برای replicate دو بار دستور کپی برایش ارسال می شود بنابر این وقتی می خواهد صف موارد را بفرستد یک پکت دو بار ارسال می شود.

بعد از اینکه بافر بزرگتر دیتا دریافت کرد یک مکانیزمی هست که هر سگمنت را با ترتیب آخرین به اولین می خواند و بدین شکل LIFO حفظ می کند و برای ارسال آن نیز از آخر به اول سعی می کند ارسال کند و اگر ارسال نشد مجدد کل سگمنت از اول به آخر طی می شود و پکت های ارسال نشده به قسمت persistent_cache_mgr ارسال می شود که مدیریت می کند هر پکت روی کدام memmap قرار گیرد

وقتی پکتی برای memmap ارسال می شود زمان پکت ذخیره می شود. دلیل آن مشکلی است که برای این برنامه قابل تصور است و آن تحمل پذیری در مقابل حجم پکت هاست که در این شرایط نباید تمام رم مصرف گردد. راهکاری که در نظر گرفتم وقتی شتاب ذخیره سازی در سگمنت ها افزایش می یابد میایم و اینطور فرض می کنم که قطعا با این نرخ ورود خروج نخواهیم داشت زیرا Tcp تقریبا کند است فلذا میایم و udp های دریافتی را مثلا یکی در میان و چند تا درمیان به سمت ارسال از طریق tcp و بقیه موارد را به سمت حافظه هارد هدایت می کنم در نتیجه سگمنت ها رشد می کند و جلوی تهاجم را می گیرد ولی خودش روی هارد تخلیه می شود. بعد از اینکه 




هر کی زیادی توی مموری بمونه و ارسال نشه ارسال میشود به فایل و memmap در نتیجه مموری زیاد اشغال نمی ماند . بعد در اثنای ارسال از مموری اگر وقت زیادی داشت و سرش خلوت بود و یا اینکه بر اساس تایمی که نگه داشته شده بابت آخرین پکت هایی که به فایل منتقل شده اولویت را می دهد به موارد داخل فایل و  اگر مجدد مموری چیزی برای ارسال داشت مجدد از اون مخزن ارسال ها را انجام می دهد
خلاصه تلاش می کند بر اساس زمان پکت ها ارسال کند و آخرین دریافتی ها را اول ارسال کند.