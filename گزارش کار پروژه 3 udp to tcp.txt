عنوان پروژه: protocol bridge یا ingestion normalizer
شروع پروژه: 14040320
تاریخ تنظیم: 14040630

==========
[14040320-14040407] - 12 روز کاری
++ ایجاد یک برنامه که udp packet های دریافتی را بشمارد. تنظیمات این برنامه توسط یک فایل json به آن داده می شود.
--- ایجاد قابلیت متغیر بودن کانفیگ برنامه حین اجرا بر اساس تغییرات اعمالی روی کانفیگ
--- خواندن packet های دریافتی از udp port توسط kernel socket
==========
[14040408-14040418] - 7 روز کاری
++ ایجاد یک برنامه برای تولید انبوه udp packet بر اساس config file
--- ایجاد یک باکس نمایش آمار توسط ncurses
--- مقایسه میزان ارسال برنامه خودم و ابزارهای تولید packet مشابه مانند netcat و hping3 و nping و wget و فایل کپی از طریق share folder
>>> نتیجه ای که حاصل شد برنامه udp generator خودم rate بالاتری برای ارسال پکت داشت بدون اینکه از محدوده MTU packet size تجاوز کند
==========
[14040421-14040508] - 15 روز کاری
++ بررسی علت packet لاست در سمت گیرنده خودم
--- بررسی میزان lost ابزار های مشابه مانند tcpdump و tshark و iftop و iperf
--- بررسی ابزار های دیگری به غیر از kernel socket برای دریافت udp packet. ابزار هایی از قبیل pfring , xdp , libpcap , DPDK , PACKET_FANOUT و AF_PACKET بررسی شد که مواردی که نیاز به کارت شبکه واقعی داشت و native mode میخواست به نتیجه نرسید و صرفا در raw packet ها pcap امکان تستش فراهم شد
>>> نتیجه ای که حاصل شد اینست که عملکرد pcap بسیار بهتر از kernel socket است
>>> در ضمن flag های BUSY_POOL و بافر سایز و cpu affinity سمت ماشین مجازی در بهبود میزان lost تاثیر مثبت داشت
==========
[14040511-14040514] - 4 روز کاری
++ ایجاد یک برنامه tcp receiver و امکان دریافت تنظیمات از فایل
==========
[14040515-14040522] - 6 روز کاری
++ اشکال یابی برنامه ام
--- بررسی علت گیر کردن دریافت udp packet ها
--- رفع مشکل قطع برنامه در صورت ایجاد Fault
>>> تاثیر مثبت port drain
>>> قطع وابستگی دریافت و ارسال پکت توسط یک circular buffer و multithreading نمودن کد
>>> retry کردن کانکشن ها
==========
[14040525-14040611] - 12 روز کاری
++ توسعه برنامه برای اجرای تنظیمات پیشرفته و ترکیبی
--- ایجاد کانفیگ پیچیده برای پیاده سازی Multi producer multi consumer و ارسال round robin , replicate پکت ها به مقصد
==========
[14040612-14040617] - 4 روز کاری
++ مشخص شدن توپولوژی مورد نیاز برای تست روی سرور واقعی
--- دریافت ip سرور ها و مهیا نمودن شرایط اجرا و Debug روی این سرور جدید
--- تست عملکرد برنامه در سرور واقعی و زیر بار و تست میزان پایداری برنامه
--- از آنجایی که udp packet فرگمنت شده تحویل می شوند، برای دور زدن مشکلات دریافت packet بصورت raw فعلا از kernel socket استفاده می شود
>>> برنامه به مدت 3 روز بر روی یکی از پورت های دریافت کننده لاگ بینش قرار گرفت و دیتا را تحویل log stash در طرف مقابل داد.(میزان لاست اندازه گیری نشد)
==========
[14040618-14040631] - 9 روز کاری
++ پیاده سازی Cache مرکزی
--- پیاده سازی circular buffer برای هر pcap و یا دریافت کننده ی یک گیت کانفیگ
--- پیاده سازی امکان ذخیره داده های دریافتی از همه گیت ها بر روی یک حافظه با circular double linked list و ایجاد امکان ارسال داده ها بر مبنای LIFO
==========

========================================
========================================

کارهای باقیمانده برای تحویل نسخه بتای اولیه: ( 9 روز کاری )
++ نمایش آمار تنظیمات پیچیده توسط notcurses( 3 روز کاری )
++ پیاده سازی persistent storage برای ذخیره حجم بالای packet های ارسال نشده به طرف مقابل ( 5 روز کاری )
--- ساختار اتوماتیک ذخیره و بازیابی از persistent storage و ارسال LIFO پکت ها
--- برنامه قابل بستن نباشد مگر اینکه همه داده ارسال نشده در هارد ذخیره شود
++ رفع memory leak ها ( 1 روز کاری )

========================================

کارهای باقیمانده برای تحویل نسخه پایدار فاز 1: ( 9 روز کاری )
++ ایجاد مکانیزمی برای از دست رفتن حتی یک لاگ بوسیله ارتباط داخلی بین دو نسخه از برنامه با ساده ترین روش ( 2 روز کاری )
++ اضافه کردن لاگ به برنامه برای ایجاد امکان بررسی fault ها ( 3 روز کاری )
++ defragment کردن پکت های دریافتی توسط raw socket ها ( 3 روز کاری )
++ تست ( 4 روز کاری )
--- تست پایداری در حجم دیتای بسیار بالا
--- تست در شرایط قطع شدن و کند شدن لینک خروجی
--- تست packet lost ( 3 روز کاری )

========================================

کارهای شناسایی شده برای فازهای آتی:
- پیاده سازی روش های دریافت raw packet منجمله XDP , DPDK
- کنترل برنامه برای توسعه پذیری برای حجم های بالای لاگ
- کنترل کانفیگ فایل و اعلام خطاهای احتمالی
- مانیتورینگ برنامه از راه دور توسط telnet مثلا
- تست پایداری در شرایط تغییر کانفیگ بصورت آنلاین
- ارسال کانفیگ از طریق telnet
- ایجاد test case های لازم برای قسمت های مختلف کد
- تست subroutine های پایه
- اضافه کردن توضیحات به کدها
- امکان موازی سازی خروجی به چند مقصد log stash در صورت تاکید در کانفیگ فایل
- gracefull degrade کردن برنامه و عدم قطع برنامه در شرایط Failure
- اگر در خروجی امکانش بود که فراتر از MTU داده ارسال کنم اینکار به تخلیه high performace داده ذخیره شده کمک می کند
- ایجاد یک سیستم هشدار برای شرایطی که ادامه سیاست عدم دسترسی به یک لاگ دچار مشکل می گردد مانند پر شدن هارد و یا رم

