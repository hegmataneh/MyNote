to learn
{

	glibc

	cast int64 to short what exactly do . consider that dynamic cast is not allowed in c

	Ø´Ú©Ù† Ù†ØµØ¨ Ú©Ù† for copilot

	Ø¢ÛŒØ§ ØªØ±Ø¯ Ù‡Ø§ÛŒ Ù…Ø§ Ø±Ø§ Ø±ÙˆÛŒ Ú©ÙˆØ± Ù‡Ø§ÛŒ Ø®Ø§Ù„ÛŒ Ù…ÛŒ Ø§Ù†Ø¯Ø§Ø²Ø¯ Ø§Ú¯Ø± Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯

	ps . psfax
	
	map reduce in architucture
	
	lsof

	linux

	bgp.tools ?
	
	how to close ipv6
	
	Livelock

	vectorization techniques for performance

	scattering cpu affinity

	from dr.akbari https://refactoring.guru/

	TUI (text user interface)
	lib TUI check

	If you donâ€™t want to code all in C, you can make your C app output data and pipe it to:

	art of monitoring

	Ø§Ø² Ù†Ø¸Ø± Ù†ÙˆØ¹ Ùˆ ØªÚ©Ù†ÛŒÚ©ØŒ Ø­Ù…Ù„Ø§Øª â€œUDP NULLâ€ Ø¨Ø§ Ø³Ù‡Ù… ÛµÛ¹.ÛµÛ³Ùª ØºØ§Ù„Ø¨ Ù‡Ø³ØªÙ†Ø¯. Ù¾Ø³ Ø§Ø² Ø¢Ù† â€œDNS Amplificationâ€ Ø¨Ø§ Ø­Ø¯ÙˆØ¯ Û±ÛµÙª Ùˆ â€œTCP Malformedâ€ Ø¨Ø§ Û±Û´Ùª Ø¯Ø± Ø¬Ø§ÛŒÚ¯Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ù†Ø¯. Ø­Ù…Ù„Ø§ØªÛŒ Ø¨Ø§ ØªÚ©Ù†ÛŒÚ©â€ŒÙ‡Ø§ÛŒÛŒ Ù†Ø¸ÛŒØ± ACK FloodØŒ Ø­Ù…Ù„Ù‡ ØªØ±Ú©ÛŒØ¨ÛŒ Ø¨Ø±â€ŒØ§Ø³Ø§Ø³ DNSØŒ Ùˆ Ø³Ø§ÛŒØ± Ø±ÙˆØ´â€ŒÙ‡Ø§ Ù†ÛŒØ² Ø¨Ù‡ ØªØ±ØªÛŒØ¨ Ù…Ø·Ø±Ø­ Ù‡Ø³ØªÙ†Ø¯. Ø§ÛŒÙ† ØªÙ†ÙˆØ¹ Ø±ÙˆØ´â€ŒÙ‡Ø§ Ù†Ø´Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ú©Ù‡ Ù…Ù‡Ø§Ø¬Ù…Ø§Ù† ØªÙ„Ø§Ø´ Ø¯Ø§Ø´ØªÙ‡â€ŒØ§Ù†Ø¯ Ø§Ø² Ø§Ù†ÙˆØ§Ø¹ Ù…Ø®ØªÙ„ÙÛŒ Ø§Ø² Ø­Ù…Ù„Ø§Øª Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø®ØªÙ„Ø§Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ù†Ø¯.


	hazard pointer

	hazard structure

	atomic variable

	synchronize 

	hyper thread

	lockless algorithm

	redis as in memory database

	psfax
	
	

}

lock and mutex and thread
{

Good â€” youâ€™ve hit the core of **POSIX threading synchronization**. To â€œmasterâ€ this area, you want to understand a few major concepts, primitives, and design patterns. Iâ€™ll organize this into **headlines/titles** (things you can study), and then a short note for each:

---

## ğŸ”‘ Core Synchronization Primitives (POSIX Threads)

1. **Mutexes (`pthread_mutex_t`)**

   * Mutual exclusion locks: ensure only one thread enters a critical section at a time.
   * Types: normal, recursive, error-checking.

2. **Condition Variables (`pthread_cond_t`)**

   * Work with a mutex to allow threads to wait for conditions.
   * Functions: `pthread_cond_wait`, `pthread_cond_signal`, `pthread_cond_broadcast`.
   * Key feature: atomic â€œwait-unlock-sleepâ€ operation.

3. **Semaphores (`sem_t`)**

   * Counting resources (binary semaphore is like a mutex).
   * Often simpler for producer/consumer models.

4. **Readâ€“Write Locks (`pthread_rwlock_t`)**

   * Allow multiple readers or one writer.

5. **Barriers (`pthread_barrier_t`)**

   * Synchronize phases of execution (all threads reach a barrier before continuing).

---

## âš™ï¸ Important Concepts

6. **Critical Sections**

   * Regions of code where shared state is accessed.

7. **Race Conditions**

   * When correctness depends on unpredictable timing.

8. **Deadlock**

   * Two (or more) threads wait forever for each otherâ€™s locks.

9. **Starvation / Fairness**

   * When a thread never gets the resource it needs because others keep acquiring it.

10. **Spurious Wakeups**

    * Condition variables may return without a signal â†’ always use `while(...)` not `if(...)`.

11. **Lost Wakeups**

    * Why `pthread_cond_wait` must atomically release-lock-and-sleep (to avoid missing a signal).

---

## ğŸ§© Common Synchronization Patterns

12. **Producerâ€“Consumer Queue**

* Uses mutex + condition variables (like your circular buffer).

13. **Readersâ€“Writers Problem**

* Optimizing access when reads are common and writes are rare.

14. **Dining Philosophers**

* Classic deadlock/starvation example.

15. **Thread-safe Initialization (Once)**

* `pthread_once` for one-time initialization across threads.

16. **Double-checked Locking**

* Optimization pattern (must be careful with memory ordering).

---

## ğŸ§  Deeper Topics (Advanced)

17. **Memory Visibility & Ordering**

* Mutexes also act as memory fences/barriers.

18. **Futex (Fast Userspace Mutex, Linux)**

* Lower-level primitive behind pthreads.

19. **Lock-free / Wait-free Data Structures**

* Using atomics instead of locks.

20. **Real-time Scheduling & Priority Inversion**

* Priority inheritance with mutexes.

---

## ğŸ“š Good References

* **Books**:

  * *Programming with POSIX Threads* â€” David R. Butenhof (classic).
  * *The Linux Programming Interface* â€” Michael Kerrisk (great for system-level).
  * *Operating Systems: Three Easy Pieces* â€” Remzi Arpaci-Dusseau (free online).

* **Manual Pages**:

  * `man pthreads`, `man pthread_mutex_lock`, `man pthread_cond_wait`.

---

ğŸ‘‰ If you focus on **mutex + condition variables + producer/consumer pattern** first, youâ€™ll already cover \~80% of practical multithreading in C. The rest builds from there.

Do you want me to prepare a **learning roadmap** (step-by-step exercises with mutex/cond/sem) so you can practice and cement these concepts in C?


}


questions:
{

	-----------

	in iPerf command By default, iPerf uses 1470 bytes for UDP payload (to avoid fragmentation over Ethernet with a standard 1500-byte MTU).

	fragmentation over Ethernet 

	ÛŒØ¹Ù†ÛŒ Ú†ÛŒ

	--------

	Ø¯Ø± Ø²Ø¨Ø§Ù† c exceptio Ù†Ø¯Ø§Ø±ÛŒÙ… ÙˆÙ„ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø§Ø±ÛŒÙ…. Ø­Ø§Ù„Ø§ Ú†Ø¬ÙˆØ±ÛŒ Ú©Ø§Ø± Ù…ÛŒÚ©Ù†Ù‡

	--------

	Ø³ÙˆØ§Ù„ . udp Ø§Ù†ØµØ§Ù„Ø´ Ú†Ø¬ÙˆØ±ÛŒ Ø§Ø³Øª Ø¢ÛŒØ§ ÛŒÚ© Ø³ÙˆÚ©Øª Ø¯Ø±Ø³Øª Ù…ÛŒ Ú©Ù†ÛŒÙ… Ùˆ Ø§Ø±Ø³Ø§Ù„ Ù… ÛŒÚ©Ù†ÛŒÙ… Ø§ÛŒÙ†Ù‡Ø§ Ø¨Ø§ Ù‡Ù… Ø§Ø±ØªØ¨Ø§Ø·ÛŒ Ù†Ø¯Ø§Ø±Ù†Ø¯.

	Ø¢ÛŒØ§ Ù…ÛŒØ´Ù‡ Ø¯Ø± Ø³Ø·Ø­ Ù„Ø§ÛŒÙ‡ Ù‡Ø§ÛŒ Ø´Ø¨Ú©Ù‡ Ú©Ø¯ Ù†ÙˆÛŒØ³ÛŒ Ú©Ø±Ø¯ ÛŒØ¹Ù†ÛŒ Ú©Ø±Ù†Ù„ Ø±Ø§ Ø¯ÙˆØ± Ø²Ø¯

	Ø³ÙˆÚ©Øª Ø¨Ø§Ø² Ù…ÛŒ Ú©Ù†ÛŒÙ… Ø§Ø² Ú©Ø¯Ø§Ù… Ù„Ø§ÛŒÙ‡ Ø´Ø¨Ú©Ù‡ Ø´Ø±ÙˆØ¹ Ù…ÛŒ Ú©Ù†Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯Ù† Ø¯Ø± ÙˆÛŒÙ†Ø¯ÙˆØ² Ùˆ Ù„ÛŒÙ†ÙˆÚ©Ø³

	ÛŒÚ© ØªÙˆØ¶ÛŒØ­ÛŒ Ú©Ù‡ ÛŒÚ© Ø³ÙˆÚ©Øª Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ùˆ Ù…Ø±Ø§Ø­Ù„ Ø¢Ù† Ø±ÙˆÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ù„Ø§ÛŒÙ‡ Ù‡Ø§ÛŒ Ú†Ú¯ÙˆÙ†Ù‡ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒ Ø´ÙˆØ¯

}


ideas
{
	
	red button to cancel all operation

	load prev settings

	echo current using setting

	testebility

	nullable

	empty argument

	crc changes

	check struct with just one nested struct has sizeof() inner struct only not more

	donot make fragment memory allocation

	---------

	to serach/Reasearch:

	RTT 70 mili second yani chi
	google analytics


	gdb version
	cmake  
	what s gcc and difference to g++
	powershell
	CLang


	SOLID principles
	Build systems & dependency management (e.g., Maven, Gradle, CMake)
	IntelliJ
	CI/CD systems


	ğŸ”§ 9. Diagnostics and Monitoring Tools
	Tools: , traceroute, netstat, wireshark, nslookup, dig, nmap, curl

	Why: Troubleshooting and verifying connectivity are core skills.


	ğŸ”„ 10. Reverse Proxies and Load Balancers
	Concepts: Nginx, HAProxy, Layer 4 vs Layer 7 balancing

	Why: Needed for scaling, SSL termination, and request routing in web apps.

	Concepts: SNAT, DNAT, PAT, port mapping

	DNS resolution failure

	Port conflicts

	Firewall blocking

	NAT loopback issues

	MTU mismatch or packet fragmentation

	Rate limiting and throttling

	Network Performance Issues


	Issue	Description

	Latency	Time delay between sender and receiver

	Packet Loss	Packets get lost due to overload, interference, or bad routing
	Bandwidth Saturation	Network link is constantly used to max capacity
	Bufferbloat	Excessive buffering causes delay (common in routers)

	Every network device (routers, switches, NICs, OS sockets) uses buffers.

	Ø¯Ø± Ø®ØµÙˆØµ Ø¹ÛŒÙ†Ú© Ù…ÙˆØ¶ÙˆØ¹ blucut Ùˆ bluecontrol ØªØ­Ù‚ÛŒÙ‚ Ø´ÙˆØ¯ Ú¯ÙˆÛŒØ§ Ø¨Ù„Ùˆ Ú©Ù†ØªØ±Ù„ Ø¨Ù‡ØªØ± Ø¹Ù…Ù„ Ù…ÛŒ Ú©Ù†Ø¯

}
