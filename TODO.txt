
- راه اندازی و رفع باگ سنیتایزر روی سرور بالا

- تست با rcp replay

- چرا pcap کار نکرد در سرور بالا

- فکر کنم نام کانفیگ مشکل داشت که دو تا AB ایجاد کرد

- چرا وقتی کانکشن را از روی نام tcp پیدا کرد آنرا در dic اد نمی کند که دفعه بعد سریعتر پیداش کند

----------------

- شاید بسته به شرایط چند خروجی لازم باشد و لیست وار جلو رفتن درست نباشد

- هر ترد یک واچ داگ داشته باشد که آخرین زمان کار و شمارنده داشته باشد و به همراه هندل آن قابل ری استارت شدن باشد

- فقط memmap آخری لود باشد و بقیه رم نگیرد

- وسط کار پکتی لاست نشود

- یک جاهایی دیدم که وقتی برنامه را میخواستم ببندم که یعنی همه پکت ها ارسال شده بود باز یک تعداد پکت هست که ارسال نشده و گیر کرده و دور بعد که برنامه بالا می آید آنها ارسال می شوند ولی چرا در برنامه قبلی ارسال نشده

- priority thread management

- اگر برای خاموشی ناگهانی سیستم هم قرار است راه حلی ارائه گردد باید اقدام جدید گردد

- بعد ها باید یک فکری بکنم زیرا مثلا اگر یک پکت ارسال نشدنی سر استک قرار بگیرد آیا بقیه موارد اون لیست چه اتفاقی برایش می افتد

- آیا برنامم میتونه از همه مموری و هارد استفاده کنه

- فقط مخزن رم و هارد را درست کنم و امکان چند برنامه و پورت به برنامه جدید را ایجاد کنم

- فقط موارد اسال نشده نرود در هارد بلکه ارتباط هارد و رم خیلی هوشمندانه تر باشد

- WAL

- چه نرخی برود روی هارد 

// TODO . later if we have repelase  least used item is good idea - dict_fast

برای pthread_mutex_init ها هم Break_stat اینا بزار

- هر برنامه یا هر فایل کانفیگ یک GUID داشته باشد در نتیجه وقتی دو تا نسخه بالا می آید بتوانی بگوییم از اونیکی برنامه دیتاش توی فایلشو بگیر

- تست packet lost

- فقط مخزن رم و هارد را درست کنم و امکان چند برنامه و پورت به برنامه جدید را ایجاد کنم

- و دیمن کردن و بالا بودن برنامه

- برنامه جوری باشد که هر ورژنی تا دیتای خود را تحویل نداده نپرد بیرون. راهی که به ذهنم رسید از طریق کانکشن داخلی بین برنامه است localhost

- یا کش خود را در هارد بریزد تا بعدی که بالا میاید آنرا بخواند و ارسال کند

- log

- اندازه الوکیت که به مموری بخورد و به هارد هم باید از کانفیگ بیاید

- monitoring

- بعدا یک counter  بگذارم اول همه خطوط که بشود جایی که بیشترین hit را دارد را به عنوان باتل نک شناسایی و سریع کنم . بعدا

- tcp relay , pcap یک مقداری لاگ که خودم ریت را کم و زیاد کنم

- درایور igb یا igvuio برای xdp برای vm , pci genereic

- خروجی مشخص باشد چه ریتی باشد . ریت لیمیت خروجی

- چه درصدی از رم و هارد پر شود یک آلارمی بدهد

- bigint

- هر کی یک چیزی Alloc می کند و واگذار می کند به بیرون که پاک کند باید بنویسد که آنرا پاک کند

- مقدار buff از تنظیمات بیاید

- باید بتوانم فایل کانفیگ را بگیرم و عیب هایش را لیست کنم که تداخل اجرا قبل از شروع مشخص شود و نه اینکه برود در برنامه و اونجا عزا بیگرم

- هر تکه از کانفیگ GUID داشته باشد که بشود فقط یک تکه از آنرا بروز رسانی کرد

- اگر کانفیگی را دارد پاک می کند و مربوط به دسته ای از پکت هاست که هنوز ارسال نشده اونوقت چی

- البته الان هم به ذهنم رسید با دستکاری ارسال کننده ها و وجود یک سرور مشابه همانند واسط می شود اجرای در کنار یکدیگر در یک سرور که شاید سخت باشد پیاده سازیش را نداشته باشیم و به نوعی یک سرور بک آپ داشته باشیم

- هر input مشخص می کند یک pcap باز شود و تجمیعش کار را سخت می کند شایدم نکند و تجمیع شود بهتر باشد و بعدش مجدد مشخص شود که چند تا pcap نیاز است

- مموردی الوکیت هام بر اساسی باشد که بیشتر سرعت دسترسی ایجاد شود با توجه به NUMA 

- با یک telnet بشود به برنامه متصل شد برای اعمال کانفیگ

- اون سمت گرفتن tcp را کاری کن که هر چی کانکشن آمد بگیرد

- اولی که برنامه هام بالا می آید اعدادی که تغییر می کند یک بلینک بزند یعنی متغیر های تنظیماتی تغییر کرده مثل تعداد کانکشن Tcp

- از چت جی پی تی بپرسم چجوری میشه کلاسهای مختلف را تست کرد و زیر بار تست و انواع سناریو ها را تست کرد

- non case sensitive

- improve packet get to get 100 percet of packet

- یک ranje بگیرد و بدهد به یک پورت

- تنظیمات وارد شده می تواند conflict داشته باشد. زیرا دو نفر نمی توانند یک پورت tcp باز کنند

- multi process listener

- فیلد های ولید در قسمت کانفیگ ها پر شود

- چرا وقتی یکی در حال پکت ارسال کردن است برنامه من که از وسط کار رسیده نمی تونه ببینه این پکت را و سلک کار نمی کنه ولی اگر تست کنم برنامه دیگر کار کند این بده

- وقتی پکت یو دی پی را نگیریم کار گیر می کند و ارسال متوقف می شود و پورت دیگر ارور می دهد

- چرا اگر پورت udp را نگیریم گیز می کند و علت چیست

- install linux and vs code on it

- هر وقت ورژن زدی تاریخش رو ثبت کن 

- هر کاری میکنی یک جایی لاگ فایل داشته باش

--

سلام صبح به خیر
من یه نگاه اجمالی به iperf کردم. ما هدفمون چیه؟ هدفمون اینه که با حداکثر bitrateی که پهنای باند ما اجازه میده اگر pktها ارسال بشه به ورودی دستگاه وسط بتونه همه اونها رو process کنه و اگر نمیکنه ببینیم حداکثر rateی که میتونیم pkt ارسال کنیم تا همه process بشن چقدره یا به عبارتی چند درصد از pktها در حالت ارسال حداکثری lost میشن. در اثر چی lost میشن؟ در اثر زمانی که ما لازم داریم برای اینکه اونها رو process کنیم. طبعاً وقتی میخواهیم از اون طرف ارسالشون هم بکنیم به سرور سوم این زمان بیشتر هم میشه. پس تست کامل ما وقتی هست که همه مراحل انجام بشه. برای اینکه بتونیم جدا جدا هم این اطلاعات رو داشته باشیم و بدونیم چقدر از بار process صرف دریافت pktها شده و چقدر صرف ساخت pktهای ارسالی به سرور سوم و ارسال اونها طبعاً این benchmarking باید در داخل خود برنامه باشه که بتونه بار process هر بخش رو به طور جداگانه به ما نشون بده. اما نهایتاً اون چیزی که میخواهیم بدونیم اینه که حداکثر با چه rateی میتونه سرور اول pktها رو ارسال کنه که تمام اونها توسط سرور سوم دریافت بشه. حالا اگه این ابزار میتونه این اطلاعات رو به ما بده که خوبه، ازش استفاده میکنیم. طبعاً با configهای مختلف میخواهیم این اطلاعات رو به دست بیاریم. وقتی تعداد portهای ورودی زیاد میشه چه تأثیری داره و وقتی تعداد خروجیها زیاد میشه چه تأثیری. از این جور بازیها میخوایم باهاش درآریم و اطلاعات processorی که در سرور وسط نشسته رو بدونیم. این میشه در واقع اون benchmark کردنه.

لینک بین سرورها در virtual machine به لحاظ توانایی بالا بردن bitrate به چی بستگی داره؟ خود اون driverی که برای virtual machine گذاشته‌اند دخیله یا پارامترهای دیگه هم هست؟ اینم یه موضوعیه که در تستهای ما دخالت میکنه. البته اگه ما بتونیم لینک با پهنای باند بالا روی سرورهای physical داشته باشیم تست دقیقتری خواهیم داشت. ولی خب حالا فعلاً همین رو سعی کنیم تا بتونیم منطبق بر واقعش کنیم.

5. Signals / Interrupts
Problem: Signals like SIGINT, SIGTERM, or SIGPIPE can terminate the program.
Mitigation: Install signal handlers:
struct sigaction sa;
sa.sa_handler = handle_sigint;
sigaction(SIGINT, &sa, NULL);


9. TCP Backpressure
Problem: TCP send() can block if the socket buffer is full.
Mitigation: Use non-blocking sockets, handle EAGAIN/EWOULDBLOCK.


15. File / Disk I/O
Problem: If program writes to disk and disk is full or unavailable, program may crash.
Mitigation: Check return values for all I/O.


18. Integer Overflow / Underflow -- very important
Problem: Using packet sizes as int and overflowing can cause allocation issues.
Mitigation: Use size_t and check for overflow before allocation.


20. Improper Cleanup on Exit
Problem: Not freeing resources on exit may cause undefined behavior or leaks in repeated restart.
Mitigation: Use atexit() handlers or cleanup functions.

Invalid File Descriptor Usage: Polling or reading/writing on closed/invalid sockets (e.g., after peer disconnect).
Mitigation: Check FD validity with fcntl(fd, F_GETFD); before operations; handle EBADF errors.

