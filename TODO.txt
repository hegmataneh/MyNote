
- فقط مخزن رم و هارد را درست کنم و امکان چند برنامه و پورت به برنامه جدید را ایجاد کنم
- و دیمن کردن و بالا بودن برنامه
- برنامه جوری باشد که هر ورژنی تا دیتای خود را تحویل نداده نپرد بیرون. راهی که به ذهنم رسید از طریق کانکشن داخلی بین برنامه است localhost
- priority thread management
- log
- مموری پر شود برود سراغ هارد پرسیستنت تری

- اندازه الوکیت که به مموری بخورد و به هارد هم باید از کانفیگ بیاید

----------

- رعایت false sharing و alignment را بکن سرعت رایت بیشتر بشه .
بین متغیر های با دسترسی زیاد 64 Byte فاصله باشه و کل ساختار align 64 باشه


- monitoring

- بعدا یک counter  بگذارم اول همه خطوط که بشود جایی که بیشترین hit را دارد را به عنوان باتل نک شناسایی و سریع کنم . بعدا

- tcp relay , pcap یک مقداری لاگ که خودم ریت را کم و زیاد کنم

- درایور igb یا igvuio برای xdp برای vm , pci genereic

- ingestion normalize برنامه منه

از برنامه tst_notcurses_tabs_gpt استایل های خوب را انتخاب کردم و آنرا در قالب یک جدول و تب خوب بسازم و بعد در برنامه اصلی پیاده کنم

- کاری کنم که آمار هر قسمت کانفیگ جدا نمایش داده بشه
- اون قسمتی که چند برنامه بشه بیاد بالا و فقط یکیش کار رو دست بگیره تا نوبت بعدی بشه هم خیلی مهمه

- خروجی مشخص باشد چه ریتی باشد . ریت لیمیت خروجی

- چه درصدی از رم و هارد پر شود یک آلارمی بدهد

- اولویت کدام بافر بیشتر باشد برای ارسال

- چه نرخی برود روی هارد 

- تقدم با مموری است و بعد هارد

- bigint

- tag function thread safe and largedata

- هر کی یک چیزی Alloc می کند و واگذار می کند به بیرون که پاک کمند باید بنویسد که آنرا پاک کند

- مقدار buff از تنظیمات بیاید

- باید بتوانم فایل کانفیگ را بگیرم و عیب هایش را لیست کنم که تداخل اجرا قبل از شروع مشخص شود و نه اینکه برود در برنامه و اونجا عزا بیگرم

- هر تکه از کانفیگ GUID داشته باشد که بشود فقط یک تکه از آنرا بروز رسانی کرد

- اون مخزن نگهداری در فایل

- اولویت دهی به خالی کردن جدید ها نسبت به قدیمی ها

- قطع شدن لینک ها تاثیر گذار نباشد

- 


--------------

هر input مشخص می کند یک pcap باز شود و تجمیعش کار را سخت می کند شایدم نکند و تجمیع شود بهتر باشد و بعدش مجدد مشخص شود که چند تا pcap نیاز است


- من هم بتوانم تشخیص دهم که MTU ارتباطی بین من و خروجی چقدر است و اگر برایم امکان دارد حجم داده بیشتر ارسال کنم و از بار انتقال زودتر کم کنم

- مموردی الوکیت هام بر اساسی باشد که بیشتر سرعت دسترسی ایجاد شود با توجه به NUMA 

- Affinity هام درست باشد که thread ها در دسترسی به حافظه بیشترین سرعت را داشته باشند

- همزمان no_wait و busy_poll استفاده شود که گیر نکند و هی بگیم دیتا بده


5. Signals / Interrupts
Problem: Signals like SIGINT, SIGTERM, or SIGPIPE can terminate the program.
Mitigation: Install signal handlers:
struct sigaction sa;
sa.sa_handler = handle_sigint;
sigaction(SIGINT, &sa, NULL);


9. TCP Backpressure
Problem: TCP send() can block if the socket buffer is full.
Mitigation: Use non-blocking sockets, handle EAGAIN/EWOULDBLOCK.


15. File / Disk I/O
Problem: If program writes to disk and disk is full or unavailable, program may crash.
Mitigation: Check return values for all I/O.


18. Integer Overflow / Underflow -- very important
Problem: Using packet sizes as int and overflowing can cause allocation issues.
Mitigation: Use size_t and check for overflow before allocation.


20. Improper Cleanup on Exit
Problem: Not freeing resources on exit may cause undefined behavior or leaks in repeated restart.
Mitigation: Use atexit() handlers or cleanup functions.

Invalid File Descriptor Usage: Polling or reading/writing on closed/invalid sockets (e.g., after peer disconnect).
Mitigation: Check FD validity with fcntl(fd, F_GETFD); before operations; handle EBADF errors.

- قانون first touch را برای مموری ها رعایت کن


ارسالی ما لزوما تک پکت نیست و شاید تجمیعی هم باشد
یا بر اساس لود تصمیم بگیرد چند تا چند تا در یک پکت tcp بفرستد

-  اومدیم چند تا کانفیگ در کنار هم بود بعدش چی نمیشه که فقط یک دونه libpcap داشته باشیم مثلا


- شاید اونجایی که قرار است چند تا پکت را یکی کنیم یا اصطلاحا سریالایز کنیم لازم باشد که چک کنیم مقدار نهایی از mtu بیشتر نشود زیرا خب می شکند شاید و شاید ایجاد مشکل کند

- هیچ وقت اسم متغیر را i , j نگذار

- تابع هش دیکشنری را کوچک گنم

- اصلا اصل تفکیک خروجی برای tcp شدن برای این بود که مثلا راند رابین پخش بشه بین چند تا خروجی، تا سریعتر بره

- با یک telnet بشود به برنامه متصل شد برای اعمال کانفیگ

- یک سری چیزها رو غیر مرتبط کن با sub pub

یک جاهایی برنامه بریدج گیر میکند گویا، ببینم مشکل کجاست

روش کرنل دیسپتچ کند


XDS خیلی لو لول تر است و فقط روی شبکه واقعی قابل تست است

{

- برنامه به نحوی باشد که بشود از lib های مختلفی استفاده کرد و اینها مثل یک interface باشد

- اون سمت گرفتن tcp را کاری کن که هر چی کانکشن آمد بگیرد

- همه توابع که ورودی می گیرد چک کند مقدارش نال نباشد مثلا زیرا خروجی های چت جی پی تی همه اش اینرا رعایت می کند

- اولی که برنامه هام بالا می آید اعدادی که تغییر می کند یک بلینک بزند یعنی متغیر های تنظیماتی تغییر کرده مثل تعداد کانکشن Tcp

- memory leaks

- gracefull degredation

- از چت جی پی تی بپرسم چجوری میشه کلاسهای مختلف را تست کرد و زیر بار تست و انواع سناریو ها را تست کرد

- descent closure

- comment fxn

- test case 

- non case sensitive

- improve packet get to get 100 percet of packet

3- یک ranje بگیرد و بدهد به یک پورت

6- چه rate ای فرستنده بفرستد که بعد از رسیدن udp و تبدیل به tcp نهایتا lost نداشته باشیم

8- تنظیمات وارد شده می تواند conflict داشته باشد. زیرا دو نفر نمی توانند یک پورت tcp باز کنند

10- عدم گیر برنامه در صورت بسته شدن tvp پورت


11- هر ترد یک واچ داگ داشته باشد که آخرین زمان کار و شمارنده داشته باشد و به همراه هندل آن قابل ری استارت شدن باشد

12- برای سمت فرستنده udp کاری کنم بشود پهنای باند تعیین کنیم که فاصله زمانی را خودش تنظیم کند مثلا

}

-----------

multi process listener

فیلد های ولید در قسمت کانفیگ ها پر شود

------------

+++++ چرا وقتی یکی در حال پکت ارسال کردن است برنامه من که از وسط کار رسیده نمی تونه ببینه این پکت را و سلک کار نمی کنه ولی اگر تست کنم برنامه دیگر کار کند این بده

وقتی پکت یو دی پی را نگیریم کار گیر می کند و ارسال متوقف می شود و پورت دیگر ارور می دهد

چرا اگر پورت udp را نگیریم گیز می کند و علت چیست

و تست هام رو حجم های متفاوت بفرستم که در واقع اندازه هدر تحت شعاع قرار بگیرد و یا نگیرد

مقایسه آمار وقتی مالی ترد و تعداد پورت زیاد داریم و با باتل نک های متفاوت باشد رفتار نتایج چه می شود

install linux and vs code on it

-------

- هر وقت ورژن زدی تاریخش رو ثبت کن 
- هر کاری میکنی یک جایی لاگ فایل داشته باش

--

سلام صبح به خیر
من یه نگاه اجمالی به iperf کردم. ما هدفمون چیه؟ هدفمون اینه که با حداکثر bitrateی که پهنای باند ما اجازه میده اگر pktها ارسال بشه به ورودی دستگاه وسط بتونه همه اونها رو process کنه و اگر نمیکنه ببینیم حداکثر rateی که میتونیم pkt ارسال کنیم تا همه process بشن چقدره یا به عبارتی چند درصد از pktها در حالت ارسال حداکثری lost میشن. در اثر چی lost میشن؟ در اثر زمانی که ما لازم داریم برای اینکه اونها رو process کنیم. طبعاً وقتی میخواهیم از اون طرف ارسالشون هم بکنیم به سرور سوم این زمان بیشتر هم میشه. پس تست کامل ما وقتی هست که همه مراحل انجام بشه. برای اینکه بتونیم جدا جدا هم این اطلاعات رو داشته باشیم و بدونیم چقدر از بار process صرف دریافت pktها شده و چقدر صرف ساخت pktهای ارسالی به سرور سوم و ارسال اونها طبعاً این benchmarking باید در داخل خود برنامه باشه که بتونه بار process هر بخش رو به طور جداگانه به ما نشون بده. اما نهایتاً اون چیزی که میخواهیم بدونیم اینه که حداکثر با چه rateی میتونه سرور اول pktها رو ارسال کنه که تمام اونها توسط سرور سوم دریافت بشه. حالا اگه این ابزار میتونه این اطلاعات رو به ما بده که خوبه، ازش استفاده میکنیم. طبعاً با configهای مختلف میخواهیم این اطلاعات رو به دست بیاریم. وقتی تعداد portهای ورودی زیاد میشه چه تأثیری داره و وقتی تعداد خروجیها زیاد میشه چه تأثیری. از این جور بازیها میخوایم باهاش درآریم و اطلاعات processorی که در سرور وسط نشسته رو بدونیم. این میشه در واقع اون benchmark کردنه.

لینک بین سرورها در virtual machine به لحاظ توانایی بالا بردن bitrate به چی بستگی داره؟ خود اون driverی که برای virtual machine گذاشته‌اند دخیله یا پارامترهای دیگه هم هست؟ اینم یه موضوعیه که در تستهای ما دخالت میکنه. البته اگه ما بتونیم لینک با پهنای باند بالا روی سرورهای physical داشته باشیم تست دقیقتری خواهیم داشت. ولی خب حالا فعلاً همین رو سعی کنیم تا بتونیم منطبق بر واقعش کنیم.

یه نکته‌ای رو شاید یادم رفت بگم اینه که نوع فرستادن به پورتهای خروجی رو هم میخوایم بتونیم در config بیاریم. دقیقترش رو حالا بعداً بهت میگم ولی اینو در نظر داشته باش. ممکنه بخواهیم یه pkt رو به بیش از یک port بفرستیم (duplicate) یا مشخص کنیم کدوم پورتهای ورودی به کدوم خروجیها برن. یا ممکنه بخواهیم بالانس بین خروجیها توسط خود نرم افزار برقرار بشه. یعنی خودش بر اساس بار هر خروجی تصمیم بگیره به کدوم بفرسته که موازنه رعایت بشه.


