

- load memmap file base on date

- فقط memmap آخری لود باشد و بقیه رم نگیرد

- وقتی حجم لود زیاد باشد فکر میکنم زیادی می ریزد روی مموری فلذا مموری پر می شود باید راهی درست کنم که اضافه را در فایل بریزد

- ته مموری لیک

- وسط کار پکتی لاست نشود

- یک جاهایی دیدم که وقتی برنامه را میخواستم ببندم که یعنی همه پکت ها ارسال شده بود باز یک تعداد پکت هست که ارسال نشده و گیر کرده و دور بعد که برنامه بالا می آید آنها ارسال می شوند ولی چرا در برنامه قبلی ارسال نشده

- priority thread management

---------------------------------------

- اگر برای خاموشی ناگهانی سیستم هم قرار است راه حلی ارائه گردد باید اقدام جدید گردد

- حذف فایلهای قدیمی بلا استفاده برای memmap

- بعد ها باید یک فکری بکنم زیرا مثلا اگر یک پکت ارسال نشدنی سر استک قرار بگیرد آیا بقیه موارد اون لیست چه اتفاقی برایش می افتد



=================================
- برای زمان دادن ضریب تست هم در نظر بگیرد بسته به بزرگی کار
- در زمان دادم ضریب حواس پرتی را لحاظ کن
- ضریب معاشرت
- ضریب مطالعه هم در نظر بگیر
- برای ریسک های احتمالی کار نکردن زمان در نظر بگیر( زمان تخمینی بدهیم و دقیق بهش عمل کنیم مگه میشه )
- ضریب پروژه جدید و تحقیق در خصوص feasibility
- ضریب استراحت
- 
=================================

- آیا برنامم میتونه از همه مموری و هارد استفاده کنه

- فقط مخزن رم و هارد را درست کنم و امکان چند برنامه و پورت به برنامه جدید را ایجاد کنم

- فقط موارد اسال نشده نرود در هارد بلکه ارتباط هارد و رم خیلی هوشمندانه تر باشد

- WAL

- چه نرخی برود روی هارد 

// TODO . later if we have repelase  least used item is good idea - dict_fast

برای pthread_mutex_init ها هم Break_stat اینا بزار

- هر برنامه یا هر فایل کانفیگ یک GUID داشته باشد در نتیجه وقتی دو تا نسخه بالا می آید بتوانی بگوییم از اونیکی برنامه دیتاش توی فایلشو بگیر

- با این فرض زمان نده که همه چیز خوب پیش میره

- memory move unsafe tags my code

- تست packet lost

- فقط مخزن رم و هارد را درست کنم و امکان چند برنامه و پورت به برنامه جدید را ایجاد کنم

- و دیمن کردن و بالا بودن برنامه

- برنامه جوری باشد که هر ورژنی تا دیتای خود را تحویل نداده نپرد بیرون. راهی که به ذهنم رسید از طریق کانکشن داخلی بین برنامه است localhost

- یا کش خود را در هارد بریزد تا بعدی که بالا میاید آنرا بخواند و ارسال کند

- log

- اندازه الوکیت که به مموری بخورد و به هارد هم باید از کانفیگ بیاید

- رعایت false sharing و alignment را بکن سرعت رایت بیشتر بشه . جایی که چند تا ترد متغیر های نزدیک هم را تاچ می کند
بین متغیر های با دسترسی زیاد 64 Byte فاصله باشه و کل ساختار align 64 باشه

- monitoring

- بعدا یک counter  بگذارم اول همه خطوط که بشود جایی که بیشترین hit را دارد را به عنوان باتل نک شناسایی و سریع کنم . بعدا

- tcp relay , pcap یک مقداری لاگ که خودم ریت را کم و زیاد کنم

- درایور igb یا igvuio برای xdp برای vm , pci genereic

- خروجی مشخص باشد چه ریتی باشد . ریت لیمیت خروجی

- چه درصدی از رم و هارد پر شود یک آلارمی بدهد

- bigint

- tag function thread safe and largedata

- هر کی یک چیزی Alloc می کند و واگذار می کند به بیرون که پاک کند باید بنویسد که آنرا پاک کند

- مقدار buff از تنظیمات بیاید

- باید بتوانم فایل کانفیگ را بگیرم و عیب هایش را لیست کنم که تداخل اجرا قبل از شروع مشخص شود و نه اینکه برود در برنامه و اونجا عزا بیگرم

- هر تکه از کانفیگ GUID داشته باشد که بشود فقط یک تکه از آنرا بروز رسانی کرد

- اگر کانفیگی را دارد پاک می کند و مربوط به دسته ای از پکت هاست که هنوز ارسال نشده اونوقت چی

- البته الان هم به ذهنم رسید با دستکاری ارسال کننده ها و وجود یک سرور مشابه همانند واسط می شود اجرای در کنار یکدیگر در یک سرور که شاید سخت باشد پیاده سازیش را نداشته باشیم و به نوعی یک سرور بک آپ داشته باشیم


هر input مشخص می کند یک pcap باز شود و تجمیعش کار را سخت می کند شایدم نکند و تجمیع شود بهتر باشد و بعدش مجدد مشخص شود که چند تا pcap نیاز است

- من هم بتوانم تشخیص دهم که MTU ارتباطی بین من و خروجی چقدر است و اگر برایم امکان دارد حجم داده بیشتر ارسال کنم و از بار انتقال زودتر کم کنم

- مموردی الوکیت هام بر اساسی باشد که بیشتر سرعت دسترسی ایجاد شود با توجه به NUMA 

- Affinity هام درست باشد که thread ها در دسترسی به حافظه بیشترین سرعت را داشته باشند

- همزمان no_wait و busy_poll استفاده شود که گیر نکند و هی بگیم دیتا بده

- قانون first touch را برای مموری ها رعایت کن

-  اومدیم چند تا کانفیگ در کنار هم بود بعدش چی نمیشه که فقط یک دونه libpcap داشته باشیم مثلا

- شاید اونجایی که قرار است چند تا پکت را یکی کنیم یا اصطلاحا سریالایز کنیم لازم باشد که چک کنیم مقدار نهایی از mtu بیشتر نشود زیرا خب می شکند شاید و شاید ایجاد مشکل کند

- هیچ وقت اسم متغیر را i , j نگذار

- اصلا اصل تفکیک خروجی برای tcp شدن برای این بود که مثلا راند رابین پخش بشه بین چند تا خروجی، تا سریعتر بره

- با یک telnet بشود به برنامه متصل شد برای اعمال کانفیگ

- یک سری چیزها رو غیر مرتبط کن با sub pub

- یک جاهایی برنامه بریدج گیر میکند گویا، ببینم مشکل کجاست

- روش کرنل دیسپتچ کند

- برنامه به نحوی باشد که بشود از lib های مختلفی استفاده کرد و اینها مثل یک interface باشد

- اون سمت گرفتن tcp را کاری کن که هر چی کانکشن آمد بگیرد

- همه توابع که ورودی می گیرد چک کند مقدارش نال نباشد مثلا زیرا خروجی های چت جی پی تی همه اش اینرا رعایت می کند

- اولی که برنامه هام بالا می آید اعدادی که تغییر می کند یک بلینک بزند یعنی متغیر های تنظیماتی تغییر کرده مثل تعداد کانکشن Tcp

- memory leaks

- gracefull degredation

- از چت جی پی تی بپرسم چجوری میشه کلاسهای مختلف را تست کرد و زیر بار تست و انواع سناریو ها را تست کرد

- descent closure

- comment fxn

- test case

- non case sensitive

- improve packet get to get 100 percet of packet

- یک ranje بگیرد و بدهد به یک پورت

- تنظیمات وارد شده می تواند conflict داشته باشد. زیرا دو نفر نمی توانند یک پورت tcp باز کنند

- عدم گیر برنامه در صورت بسته شدن tvp پورت

- هر ترد یک واچ داگ داشته باشد که آخرین زمان کار و شمارنده داشته باشد و به همراه هندل آن قابل ری استارت شدن باشد

- برای سمت فرستنده udp کاری کنم بشود پهنای باند تعیین کنیم که فاصله زمانی را خودش تنظیم کند مثلا

- multi process listener

- فیلد های ولید در قسمت کانفیگ ها پر شود

- چرا وقتی یکی در حال پکت ارسال کردن است برنامه من که از وسط کار رسیده نمی تونه ببینه این پکت را و سلک کار نمی کنه ولی اگر تست کنم برنامه دیگر کار کند این بده

- وقتی پکت یو دی پی را نگیریم کار گیر می کند و ارسال متوقف می شود و پورت دیگر ارور می دهد

- چرا اگر پورت udp را نگیریم گیز می کند و علت چیست

- install linux and vs code on it

- هر وقت ورژن زدی تاریخش رو ثبت کن 
- هر کاری میکنی یک جایی لاگ فایل داشته باش

--

سلام صبح به خیر
من یه نگاه اجمالی به iperf کردم. ما هدفمون چیه؟ هدفمون اینه که با حداکثر bitrateی که پهنای باند ما اجازه میده اگر pktها ارسال بشه به ورودی دستگاه وسط بتونه همه اونها رو process کنه و اگر نمیکنه ببینیم حداکثر rateی که میتونیم pkt ارسال کنیم تا همه process بشن چقدره یا به عبارتی چند درصد از pktها در حالت ارسال حداکثری lost میشن. در اثر چی lost میشن؟ در اثر زمانی که ما لازم داریم برای اینکه اونها رو process کنیم. طبعاً وقتی میخواهیم از اون طرف ارسالشون هم بکنیم به سرور سوم این زمان بیشتر هم میشه. پس تست کامل ما وقتی هست که همه مراحل انجام بشه. برای اینکه بتونیم جدا جدا هم این اطلاعات رو داشته باشیم و بدونیم چقدر از بار process صرف دریافت pktها شده و چقدر صرف ساخت pktهای ارسالی به سرور سوم و ارسال اونها طبعاً این benchmarking باید در داخل خود برنامه باشه که بتونه بار process هر بخش رو به طور جداگانه به ما نشون بده. اما نهایتاً اون چیزی که میخواهیم بدونیم اینه که حداکثر با چه rateی میتونه سرور اول pktها رو ارسال کنه که تمام اونها توسط سرور سوم دریافت بشه. حالا اگه این ابزار میتونه این اطلاعات رو به ما بده که خوبه، ازش استفاده میکنیم. طبعاً با configهای مختلف میخواهیم این اطلاعات رو به دست بیاریم. وقتی تعداد portهای ورودی زیاد میشه چه تأثیری داره و وقتی تعداد خروجیها زیاد میشه چه تأثیری. از این جور بازیها میخوایم باهاش درآریم و اطلاعات processorی که در سرور وسط نشسته رو بدونیم. این میشه در واقع اون benchmark کردنه.

لینک بین سرورها در virtual machine به لحاظ توانایی بالا بردن bitrate به چی بستگی داره؟ خود اون driverی که برای virtual machine گذاشته‌اند دخیله یا پارامترهای دیگه هم هست؟ اینم یه موضوعیه که در تستهای ما دخالت میکنه. البته اگه ما بتونیم لینک با پهنای باند بالا روی سرورهای physical داشته باشیم تست دقیقتری خواهیم داشت. ولی خب حالا فعلاً همین رو سعی کنیم تا بتونیم منطبق بر واقعش کنیم.

5. Signals / Interrupts
Problem: Signals like SIGINT, SIGTERM, or SIGPIPE can terminate the program.
Mitigation: Install signal handlers:
struct sigaction sa;
sa.sa_handler = handle_sigint;
sigaction(SIGINT, &sa, NULL);


9. TCP Backpressure
Problem: TCP send() can block if the socket buffer is full.
Mitigation: Use non-blocking sockets, handle EAGAIN/EWOULDBLOCK.


15. File / Disk I/O
Problem: If program writes to disk and disk is full or unavailable, program may crash.
Mitigation: Check return values for all I/O.


18. Integer Overflow / Underflow -- very important
Problem: Using packet sizes as int and overflowing can cause allocation issues.
Mitigation: Use size_t and check for overflow before allocation.


20. Improper Cleanup on Exit
Problem: Not freeing resources on exit may cause undefined behavior or leaks in repeated restart.
Mitigation: Use atexit() handlers or cleanup functions.

Invalid File Descriptor Usage: Polling or reading/writing on closed/invalid sockets (e.g., after peer disconnect).
Mitigation: Check FD validity with fcntl(fd, F_GETFD); before operations; handle EBADF errors.

